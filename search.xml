<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端 font 优化</title>
      <link href="/2021/04/11/front-end/font/"/>
      <url>/2021/04/11/front-end/font/</url>
      
        <content type="html"><![CDATA[<p>开发中，一般直接引入字体，使用即可，似乎字体本身并没有很多可以说道的地方，其实不然。字体本身涉及到印刷工业，是一个历史悠久的行业，css 字体的大部分属性都可以在印刷工业中找到映射。这篇博客，整理常见的字体使用细节。</p><h2 id="衬线体和非衬线体"><a href="#衬线体和非衬线体" class="headerlink" title="衬线体和非衬线体"></a>衬线体和非衬线体</h2><p>衬线体（英语：Serif）是一种有衬线的字体，又称为有衬线体、衬线字、曲线描边字，俗称白体字；而与之相对的，没有衬线的字体则被称为无衬线体。衬线是字形笔画的起始段与末端的装饰细节部分。<br>一般的 web 开发都倾向于无衬线体，我们在定义字体时候，应该设置完整的字体属性，衬线体或者非衬线体结尾。</p><pre class=" language-css"><code class="language-css"><span class="token selector">// 谷歌的字体设置p </span><span class="token punctuation">{</span>   <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Roboto'</span>,arial,sans-serif<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/images/16181269068142.jpg"></p><h2 id="字重"><a href="#字重" class="headerlink" title="字重"></a>字重</h2><h3 id="字重和字体名称的关系"><a href="#字重和字体名称的关系" class="headerlink" title="字重和字体名称的关系"></a>字重和字体名称的关系</h3><p>我们经常在设计稿重看到 <code>PingFangSC-Regular</code>、<code>PingFangSC-Medium</code>、<code>PingFangSC-Semibold</code> 这些字体，是3个字体吗，那么这些字体在css中应该怎么写？当成独立字体直接写，好像也没有问题，也可以解析。</p><p>但是这样，似乎是有点问题的，这些字体属于平方字体，只不过是不同的字重而已。我们直接写 <code>PingFangSC</code> 然后设置字重就可以了。</p><p>如果只是写 <code>PingFangSC-Medium</code>，不设置字重，其实也是无法生效的，会显示默认字重，也就是 <code>PingFangSC-Regular</code>。</p><p>进一步，我们为什么需要写 <code>PingFangSC</code> 字体，这个字体是苹果系统默认的中文字体。所以，设计稿是平方字体的时候，直接写 <code>font-weight</code> 好了。</p><h3 id="字体包的使用"><a href="#字体包的使用" class="headerlink" title="字体包的使用"></a>字体包的使用</h3><blockquote><p>NotoSansSC 字体<br>NotoSansSC-Thin.otf<br>NotoSansSC-Light.otf<br>NotoSansSC-Regular.otf<br>NotoSansSC-Medium.otf<br>NotoSansSC-Bold.otf<br>NotoSansSC-Black.otf</p></blockquote><p>现代字体往往会提供多种自重，相对于以往的 css bolder 会更加的精细，写法如下：</p><pre class=" language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span><span class="token punctuation">;</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token property">src</span><span class="token punctuation">:</span><span class="token string">'./NotoSansSC-Thin.otf'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span><span class="token punctuation">;</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">;</span>    <span class="token property">src</span><span class="token punctuation">:</span><span class="token string">'./NotoSansSC-Light.otf'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span><span class="token punctuation">;</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">;</span>    <span class="token property">src</span><span class="token punctuation">:</span><span class="token string">'./NotoSansSC-Regular.otf'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span><span class="token punctuation">;</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token property">src</span><span class="token punctuation">:</span><span class="token string">'./NotoSansSC-Medium.otf'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span><span class="token punctuation">;</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">;</span>    <span class="token property">src</span><span class="token punctuation">:</span><span class="token string">'./NotoSansSC-Bold.otf'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span><span class="token punctuation">;</span>    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">900</span><span class="token punctuation">;</span>    <span class="token property">src</span><span class="token punctuation">:</span><span class="token string">'./NotoSansSC-Black.otf'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre class=" language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">'Noto Sans SC'</span>, sans-serif<span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">900</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="常见计稿字体对应字重font-weight"><a href="#常见计稿字体对应字重font-weight" class="headerlink" title="常见计稿字体对应字重font-weight"></a>常见计稿字体对应字重font-weight</h3><ul><li>100 - Thin</li><li>200 - Extra Light (Ultra Light)</li><li>300 - Light</li><li>400 - Regular (Normal、Book、Roman)</li><li>500 - Medium</li><li>600 - Semi Bold (Demi Bold)</li><li>700 - Bold</li><li>800 - Extra Bold (Ultra Bold)</li><li>900 - Black (Heavy)</li></ul><h2 id="字体裁切"><a href="#字体裁切" class="headerlink" title="字体裁切"></a>字体裁切</h2><p>因为中文字体都比较大，一般都需要使用webfont等方式缩小字体大小。</p><h3 id="字蛛"><a href="#字蛛" class="headerlink" title="字蛛"></a>字蛛</h3><p>字蛛的使用限制：</p><ol><li>静态渲染内容</li><li>字体必须是 ttf 类型</li></ol><p>字体可以理解成是一种图片，裁切，保留需要用到的字符。<br>使用比较简单，把需要用到的中文写到 html 中，运行字蛛的命令即可得到需要的字符。</p><h3 id="google-font"><a href="#google-font" class="headerlink" title="google font"></a>google font</h3><p>谷歌字体的引用地址是可以使用的：<a href="https://fonts.gstatic.com/" target="_blank" rel="noopener">使用地址</a><br><img src="/images/16181293778639.jpg"></p><p>在谷歌网站上面选择相关字体，引入到项目中即可。</p><p>原理：<br>谷歌字体把中文做了分区处理，根据使用到的字符，加载相应部分，使用的时候一般 20kb 加载多条。</p><p><img src="/images/16181294659403.jpg" alt="字体分区"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%A1%AC%E7%BA%BF%E4%BD%93" target="_blank" rel="noopener">衬线体 - 维基百科，自由的百科全书</a></li><li><a href="https://github.com/o2team/H5Skills/issues/14" target="_blank" rel="noopener">前端css字体调研 · Issue #14 · o2team/H5Skills</a></li><li><a href="https://github.com/aui/font-spider" target="_blank" rel="noopener">aui/font-spider: Smart webfont compression and format conversion tool</a></li><li><a href="https://fonts.google.com/" target="_blank" rel="noopener">Browse Fonts - Google Fonts</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 中 setTimeout 计时器最大值</title>
      <link href="/2021/03/23/front-end/settimeout/"/>
      <url>/2021/03/23/front-end/settimeout/</url>
      
        <content type="html"><![CDATA[<p>项目中踩坑，记录下。<br>没有意识到 <code>setTimeout/setInterval</code> 计时器有最大值问题。</p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">31</span><span class="token punctuation">)</span></code></pre><p>这部分代码，不会等到计时器结束，而是会被会被立即执行。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>setTimeout/setInterval 使用 <code>int32</code> 存储延时参数值，也就是说最大延时值是 <code>2^31-1</code>(约为24.85天) ，超过这个值会被立即执行。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>在 web 页面中很少有需要这么大延时值得情况，根据业务场景，超过1小时，不做定时器设置，1小时以内，做定时器设置。</p><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>服务端，确实有类似的情况，比如1月一次的定时任务。建议使用 <code>corn</code> 代替 <code>setTimeout</code>，也会比 <code>setTimeout</code> 更加准确。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex 4.0 源码解析</title>
      <link href="/2021/03/10/front-end/vuex-4.0-source/"/>
      <url>/2021/03/10/front-end/vuex-4.0-source/</url>
      
        <content type="html"><![CDATA[<p>vuex 源码短小精悍，很短时间就可以大致浏览一遍，值得学习。在后续看其他框架的过程中，也发现很多框架都有参考 vuex（比如 herbjs 的插件体系）。</p><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><ol><li>一定有一个地方集中存放所有的数据（state），可以挂载到 window 上面（污染全局），或者挂载到 vue 的原型上面。</li><li>mutation action getter 这些方法，其实都是获取或者修改 state 的值，这些方法和 state 刚好可以组成一个 类（class），类封装对 state 状态的操作。</li></ol><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>4.0 版本适配了 composition api，提供了导出方法 createStore，通过它可以创建 store。<br>源码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> createStore <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Store</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>可以看到，这里只是简单的对 store 进行了一次 new 操作，返回了 store 这个类。<br>进一步查看，我们看到 install 方法，通过暴露install方法，按照 vue3 的插件规则进行安装，也就是挂载到了 vue3 的原型上面。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Store</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 暴露给 vue3 进行安装</span>  install <span class="token punctuation">(</span>app<span class="token punctuation">,</span> injectKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>    app<span class="token punctuation">.</span><span class="token function">provide</span><span class="token punctuation">(</span>injectKey <span class="token operator">||</span> storeKey<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span>$store <span class="token operator">=</span> <span class="token keyword">this</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="store-初始化"><a href="#store-初始化" class="headerlink" title="store 初始化"></a>store 初始化</h2><pre class=" language-js"><code class="language-js">constructor <span class="token punctuation">(</span>options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// webpack.DefinePlugin 配置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`vuex requires a Promise polyfill in this browser.`</span></span><span class="token punctuation">)</span>      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Store</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`store must be called with the new operator.`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>      plugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">//  严格模式，不允许在生产环境下开启，会导致性能损失</span>      strict <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span> <span class="token operator">=</span> options    <span class="token comment" spellcheck="true">// store internal state</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_actions <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_actionSubscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_mutations <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_wrappedGetters <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_modules <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModuleCollection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_modulesNamespaceMap <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_makeLocalGettersCache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// bind commit and dispatch to self</span>    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment" spellcheck="true">// 绑定 dispatch 指向自己</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dispatch <span class="token operator">=</span> <span class="token keyword">function</span> boundDispatch <span class="token punctuation">(</span>type<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> dispatch<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> payload<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commit <span class="token operator">=</span> <span class="token keyword">function</span> boundCommit <span class="token punctuation">(</span>type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> commit<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// strict mode</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>strict <span class="token operator">=</span> strict    <span class="token comment" spellcheck="true">// 定义 根state</span>    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">.</span>state    <span class="token comment" spellcheck="true">// init root module.</span>    <span class="token comment" spellcheck="true">// this also recursively registers all sub-modules</span>    <span class="token comment" spellcheck="true">// and collects all module getters inside this._wrappedGetters</span>    <span class="token comment" spellcheck="true">// 模块入口，内部注册模块，注册子模块</span>    <span class="token function">installModule</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// initialize the store state, which is responsible for the reactivity</span>    <span class="token comment" spellcheck="true">// (also registers _wrappedGetters as computed properties)</span>    <span class="token comment" spellcheck="true">// 初始化 state</span>    <span class="token function">resetStoreState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// apply plugins</span>    <span class="token comment" spellcheck="true">// 一般都是通过 store.subscribe 进行订阅，在 mutation 之后执行</span>    plugins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>plugin <span class="token operator">=</span><span class="token operator">></span> <span class="token function">plugin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> useDevtools <span class="token operator">=</span> options<span class="token punctuation">.</span>devtools <span class="token operator">!==</span> undefined <span class="token operator">?</span> options<span class="token punctuation">.</span>devtools <span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/* Vue.config.devtools */</span> <span class="token boolean">true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>useDevtools<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">devtoolPlugin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>在构造函数中，定义了一系列的参数，参数内容基本都是纯粹空 object（Object.create(null)），可以理解成在构造函数中，对所有的 commit，dispatch等进行了一次收集，触发时候，直接从这边取。<br>dispatch commit，是外界直接调用的函数，一般使用方式<code>this.$store.dispatch(&#39;increment&#39;,5);</code>,为了确保指向store本身，这里用 <code>call</code> 做了一次 this 绑定，否则这里就会指向了 <code>this</code> 也就是 vue 本身了。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><pre class=" language-js"><code class="language-js">commit <span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// check object-style commit</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>      type<span class="token punctuation">,</span>      payload<span class="token punctuation">,</span>      options    <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">unifyObjectStyle</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options<span class="token punctuation">)</span>    <span class="token keyword">const</span> mutation <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token punctuation">,</span> payload <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 取出对应的 mutations</span>    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有entry，开发模式报错</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`[vuex] unknown mutation type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 执行entry，这里为啥用 foreach，会存在 entry 数组的情况？</span>      <span class="token comment" spellcheck="true">// 测试之后，这里应该只有1个数组内容的情况，不会出现多个数组元素</span>      entry<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> commitIterator <span class="token punctuation">(</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><p>  commit 部分看起来比较简单，通过函数参数获取 type、payload、options、，取出mutation，执行mutation。<br>  这里有个疑问，为什么entry是forEach执行的，这里一般情况下，应该entry内部只有一个元素,[mutation]，这样的形式。</p><pre class=" language-js"><code class="language-js">entry<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> commitIterator <span class="token punctuation">(</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h2><pre class=" language-js"><code class="language-js"><span class="token function">dispatch</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// check object-style dispatch</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span>    type<span class="token punctuation">,</span>    payload  <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">unifyObjectStyle</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">)</span>  <span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token punctuation">,</span> payload <span class="token punctuation">}</span>  <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// before</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_actionSubscribers      <span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span>      <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> sub<span class="token punctuation">.</span>before<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> sub<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> entry<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">1</span>    <span class="token operator">?</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>handler <span class="token operator">=</span><span class="token operator">></span> <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">:</span> entry<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// dispatch 最终返回的是一个 promise</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// after</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_actionSubscribers          <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> sub<span class="token punctuation">.</span>after<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> sub<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_actionSubscribers          <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> sub<span class="token punctuation">.</span>error<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> sub<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>dispatch 相对 commit 就要复杂的多了。</p><h2 id="插件体系"><a href="#插件体系" class="headerlink" title="插件体系"></a>插件体系</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 简易入门</title>
      <link href="/2020/12/17/ops/easy-docker/"/>
      <url>/2020/12/17/ops/easy-docker/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/20180125141147_61638d31e51d85f2a5d62e04191fe55f_1.jpg" alt="齐天大圣孙悟空"></p><blockquote><p>拔一根毫毛，吹出猴万个。他叫孙悟空，也叫 docker。</p></blockquote><h2 id="docker-无所不能？"><a href="#docker-无所不能？" class="headerlink" title="docker 无所不能？"></a>docker 无所不能？</h2><ol><li>安装 wordpress</li></ol><pre class=" language-shell"><code class="language-shell">docker run --name wordpress -p 8080:80 -d wordpress</code></pre><ol start="2"><li>安装 Nextcloud 网盘</li></ol><pre class=" language-shell"><code class="language-shell">docker run -d -p 8080:80 nextcloud</code></pre><p>wordpress 安装中，我们只看到安装界面，数据库需要选择本地或者远程。Nextcloud 网盘安装中，我们安装完成就可以直接使用，因为 Nextcloud 内部默认携带了 SQLite 数据库，所以安装之后，就能够直接使用。</p><h2 id="docker-基本概念"><a href="#docker-基本概念" class="headerlink" title="docker 基本概念"></a>docker 基本概念</h2><p><strong>镜像（Image）</strong>：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>仓库（eg:dockerHub）</strong>：一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。</p><h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><p>显示可用容器：</p><pre class=" language-shell"><code class="language-shell">docker images</code></pre><p>删除指定容器：</p><pre class=" language-shell"><code class="language-shell">docker rmi <镜像ID></code></pre><p>查看容器：</p><pre class=" language-shell"><code class="language-shell">docker ps</code></pre><p>拉取并运行容器：</p><pre class=" language-shell"><code class="language-shell">docker run hello-world</code></pre><p>进入容器内部，并运行 bash：</p><pre class=" language-shell"><code class="language-shell">docker exec -it <id/container_name>  /bin/bash</code></pre><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。<br>有时候一个镜像需要很多命令，这时候可以写到 Dockerfile 文件中，一次性执行完毕。<br>我们尝试将<a href="https://github.com/Yaob1990/OMRON_Blood_Pressure_Analyse" target="_blank" rel="noopener">欧姆龙血压计</a>解析工具源码编译成一个 docker 镜像</p><ol><li><p>在项目根目录新建 Dockerfile 文件，并写上以下内容。</p><pre class=" language-shell"><code class="language-shell">FROM node:14.15.1-slimRUN yarn global add http-serverCOPY dist publicEXPOSE 4000CMD ["http-server","-p","4000"]</code></pre></li><li><p>编译项目：<code>npm run build</code></p></li><li><p>打包项目：</p><pre class=" language-shell"><code class="language-shell">docker build -t yekongbuye/omron .</code></pre></li><li><p>推送到 docker hub</p><pre class=" language-shell"><code class="language-shell">docker logindocker push yekongbuye/omron</code></pre></li></ol><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>主要是对容器进行编排。一次性编排，运行多个容器。</p><ol><li><p>创建 docker-compose.yml 文件</p><pre class=" language-yml"><code class="language-yml">version: '3.3'services:  db:    image: mysql:5.7    volumes:      - db_data:/var/lib/mysql    restart: always    environment:      MYSQL_ROOT_PASSWORD: somewordpress      MYSQL_DATABASE: wordpress      MYSQL_USER: wordpress      MYSQL_PASSWORD: wordpress  wordpress:    depends_on:      - db    image: wordpress:latest    ports:      - '8000:80'    restart: always    environment:      WORDPRESS_DB_HOST: db:3306      WORDPRESS_DB_USER: wordpress      WORDPRESS_DB_PASSWORD: wordpress      WORDPRESS_DB_NAME: wordpressvolumes:  db_data: {}</code></pre></li></ol><h2 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h2><ul><li>swarm</li><li>kubernetes（k8s）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 Tailwind 看 css 中的原子化流变</title>
      <link href="/2020/12/14/front-end/atomic-in-tailwindcss/"/>
      <url>/2020/12/14/front-end/atomic-in-tailwindcss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回不到的过去，忘不掉的人。某个路口，转角再次遇见，她还是她吗，你还是你吗？</p></blockquote><h2 id="禅意花园"><a href="#禅意花园" class="headerlink" title="禅意花园"></a>禅意花园</h2><p><a href="http://www.csszengarden.com/tr/zh-cn/" target="_blank" rel="noopener">禅意花园</a>，做前端的人或多或少都听说过项目。一样的 HTML 结构，用不同的 css 去装饰，形成截然不同的页面风格，探索 css 之美。<br><code>html css</code> 这一对欢喜冤家，谁是主，谁是客，一直没有定论。</p><h2 id="关注点即世界"><a href="#关注点即世界" class="headerlink" title="关注点即世界"></a>关注点即世界</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>btn btn-primary<span class="token punctuation">'</span></span><span class="token punctuation">></span></span> // css 依附于 html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>w50 h50 black mt30<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>   // css 原子化</code></pre><h3 id="html-friendly"><a href="#html-friendly" class="headerlink" title="html-friendly"></a>html-friendly</h3><p>第一行，使用<code>class</code>修饰<code>html</code>，也就是html-friendly，样式服务于结构。<code>class</code>每一个是有多个<code>css</code>属性，这时候的代码也更接近于日常工作中的代码，但是这样的代码如果调整起来，我们经常是直接在现有的<code>class</code>上面修改，代码会越来越长，重复的逻辑也越来越多，如果项目一直在维护，那么css基本上会一直增大。毕竟，绝大多数时候，我们只在意功能的实现。</p><h3 id="css-friendly"><a href="#css-friendly" class="headerlink" title="css-friendly"></a>css-friendly</h3><p>第二行代码,是上古时期 css 原子化的代表，推崇样式的复用。<code>width:50px;height:50px;color:balck;margin-top:30px</code>。每一个<code>class</code>都代表着一种 css 属性。原子化最早是雅虎提出来的，代表作是ACSS。ACSS 表示的是原子化 CSS（Atomic CSS），是 Yahoo 提出来的一种独特的 CSS 代码组织方式，应用在 Yahoo 首页和其他产品中。ACSS 的独特性在于它的理念与一般开发人员的理解有很大的不同，并挑战了传统意义上编写 CSS 的最佳实践，也就是关注点分离原则。ACSS 认为关注点分离原则会导致冗余、繁琐和难以维护的 CSS 代码。</p><p>ACSS 的原则是把 CSS 样式打散成尽可能小的部分，每个 CSS 类只对应一条样式规则，从而达到最大化的可复用性。比如 CSS 类 M(10px)所对应的样式规则是 margin: 10px。</p><p>岁月的洗礼，原子化，似乎已经进入了历史的垃圾堆，不管是工作中还是开源框架里，很少能看到大规模使用原子化的项目（ACSS github 1.1k start），直到 tailwind 的诞生。</p><h2 id="要有光"><a href="#要有光" class="headerlink" title="要有光"></a>要有光</h2><p>原子化虽然用的很少了，但是他的影子一直都在，项目里面<code>pl10 mt5</code>这种魔法写法一直都在。<br>现代化的前端开发，追求自适应，语义化，这些都不是传统原子化能够承担的。<br><a href="https://tailwindcss.com/" target="_blank" rel="noopener">tailwindcss</a>，应运而生，扛起了 css 原子化的大旗。<br>主要优点：</p><ul><li>着眼于现代化前端，默认单位是 <code>rem</code> 而不是 <code>px</code></li><li>丰富的预设，预设字体大小，丰富的颜色</li><li>响应式设计，提供一系列断点判断</li><li>方便扩展，根据你的项目需要，自定义相关的原子类</li><li>兼容各大框架，并有详细说明</li></ul><h2 id="是骡子是马"><a href="#是骡子是马" class="headerlink" title="是骡子是马"></a>是骡子是马</h2><p><a href="https://github.com/Yaob1990/OMRON_Blood_Pressure_Analyse" target="_blank" rel="noopener">欧姆龙血压计数据分析</a>，使用了<code>tailwindcss</code>作为基础。<br><img src="/images/16079566659385.jpg" alt="pc"></p><p><img src="/images/16079566841086.jpg" alt="mobile"></p><p>头部的响应式效果，下面是这部分代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>relative h-96<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>w-full h-96 object-cover absolute<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../assets/bg.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>w-full h-96 bg-black absolute opacity-40<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>      <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>w-full h-96 absolute flex flex-col  justify-center items-center<span class="token punctuation">"</span></span>    <span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>font text-white text-center text-4xl  font-bold<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        欧姆龙血压计数据(CSV)解析工具      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mt-8<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>upload<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>开始解析数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>瞥一眼<code>w-full h-96 absolute flex flex-col justify-center items-center</code> 这一大堆都是什么鬼东西…</p><pre class=" language-css"><code class="language-css"><span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">96</span>rem<span class="token punctuation">;</span><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span></code></pre><p>如果你觉得这样写还是有点难看，可以这样写：</p><pre><code>&lt;div class=&#39;wrapper&#39;&gt;.wrapper{    @apply w-full h-96 absolute flex flex-col justify-center items-center}</code></pre><p>是不是感觉好那么一点点…几个class，完成了响应式布局，感觉还是很不错的，而且不用想一堆 class 命名。</p><h2 id="真的那么好？"><a href="#真的那么好？" class="headerlink" title="真的那么好？"></a>真的那么好？</h2><p>初见总是美好的，相处总是困难的。</p><ul><li>写px单位，要么换算成 rem，要么自定义属性</li><li>需要新学一堆 class 语法</li><li>要思考，对公共类进行抽象，定义，不能无脑写</li><li>对 css 技能要求高，在 一堆的原子中，写一个用不到，或者不生效的 class 是不能被容忍的</li><li>项目维护是个灾难，如果接手的人不熟悉这套模式，他会想你个傻x…</li></ul><p>个人项目，天马行空，我的地盘我做主，Tailwind 用起来，小巧可人，甜而不腻。<br>公司项目，代码冗余并不是不能接收的事情，考虑到项目维护，暂不推荐。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弱水三千，只取一瓢 —— git cherry-pick</title>
      <link href="/2020/12/03/tool/git-cherry-pick/"/>
      <url>/2020/12/03/tool/git-cherry-pick/</url>
      
        <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>双主线的模式 AB，独自演进，存在一个共同的 bug，在 dev 上面修改好 bug 之后，需要合并到 AB 中，并且 A、B、dev 是一直在演进的，不能直接合并入 AB。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre class=" language-shell"><code class="language-shell">git checkout A // 切换到 A 分支git cherry-pick C1 // 拣选 C1 并合并到 A 分支git checkout B  // 切换到 B 分支git cherry-pick C1  // 拣选 C1 并合并到 B 分支</code></pre><p><code>cherry-pick</code> 捡樱桃，这名字很可爱：）。commit 就像一地的樱桃，我们需要做的就是去捡起大大小小的樱桃。</p><pre><code>$ git cherry-pick &lt;commitHash&gt;</code></pre><p>获得需要合并的 commit 值，切换到待合并的分支，执行 <code>cherry-pick</code>，</p><h3 id="详细参数"><a href="#详细参数" class="headerlink" title="详细参数"></a>详细参数</h3><pre><code>--quit                      终止反转或拣选操作--continue                  继续反转或拣选操作--abort                     取消反转或拣选操作--skip                      跳过当前提交并继续--cleanup &lt;模式&gt;             设置如何删除提交说明里的空格和#注释-n, --no-commit             不要自动提交-e, --edit                  编辑提交说明-s, --signoff               添加 Signed-off-by: 签名-m, --mainline              &lt;父编号&gt;选择主干父提交编号--rerere-autoupdate         如果可能，重用冲突解决更新索引--strategy                  &lt;策略&gt; 合并策略-X, --strategy-option       &lt;选项&gt; 合并策略的选项-S, --gpg-sign[=&lt;key-id&gt;]   GPG 提交签名-x                          追加提交名称--ff                        允许快进式--allow-empty               保留初始化的空提交--allow-empty-message       允许提交说明为空--keep-redundant-commits    保持多余的、空的提交</code></pre><h3 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h3><p>红尘过往，弱水三千，只取一瓢。<br>git 的 <code>cherry-pick</code> 是简单明确的，不会出错。而你我的生活，从没有平行宇宙，这一瓢水又从何而取…</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回到过去的一万种方式 —— git 时光机</title>
      <link href="/2020/12/02/tool/git-timemachine/"/>
      <url>/2020/12/02/tool/git-timemachine/</url>
      
        <content type="html"><![CDATA[<blockquote><p>时光无法倒流，git 却让我们有机会修改历史</p></blockquote><p>查看修改历史，代码回退是开发中经常用到的命令，但是很多时候，我们并不是非常明确其中的区别。这篇博客尝试说清楚其中的区别。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><pre class=" language-shell"><code class="language-shell">git checkout hotfix // 切换分支git checkout abbcde // 切换 commit</code></pre><p><code>checkout</code> 能够返回 commit ，用于查看 commit ，但是并不能修改或者回退 commit。</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><pre class=" language-shell"><code class="language-shell">git revert HEAD^ // 回退到上一次的提交</code></pre><p><code>revert</code> 的回退严格来说并不是回退，他是用之前的 commit ，复制一遍，产生新的 commit ，实现的代码回退。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><pre class=" language-shell"><code class="language-shell">git reset c1 // 回退commit,保留源码到工作区git reset --soft c1 // 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可；git reset --mixed c1 // 回退到某个版本，回退文件保存在工作区中，并且是 unstaged 状态，如果需要提交，需要 staged，之后再commitgit reset --hard c1 // 彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉；</code></pre><h3 id="一万种方式？？"><a href="#一万种方式？？" class="headerlink" title="一万种方式？？"></a>一万种方式？？</h3><p>一生二二生三三生万物，施主，不要有执念。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>忘记该忘记的，记住该记住的 —— git filter-branch</title>
      <link href="/2020/12/01/tool/filter-branch/"/>
      <url>/2020/12/01/tool/filter-branch/</url>
      
        <content type="html"><![CDATA[<p>Pro git 中把 <code>filter-branch</code> 称为 <strong>核弹</strong>，让人难以忘记，也充分说明了该命令的威力。</p><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><ol><li>在你的开源仓库中提交了，一个数据库的配置文件。</li><li>同事在仓库中把 <code>node_modules</code>目录提交到仓库中，并且这个目录还被后续更新过。</li></ol><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>可以使用<code>filter-branch</code>实现上述需求。</p><p>从每一个提交移除一个文件：</p><pre class=" language-shell"><code class="language-shell">git filter-branch --tree-filter 'rm -f passwords.txt' HEAD</code></pre><p>从每一个提交移除一个目录：</p><pre class=" language-shell"><code class="language-shell">git filter-branch --tree-filter 'rm -rf node_modules' HEAD</code></pre><p>限制移除范围：</p><pre class=" language-shell"><code class="language-shell">git filter-branch --tree-filter 'rm -rf node_modules' HEAD~30..HEAD</code></pre><p>全局修改邮箱地址：</p><pre class=" language-shell"><code class="language-shell">git filter-branch --commit-filter '    if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];    then      GIT_AUTHOR_NAME="Scott Chacon";      GIT_AUTHOR_EMAIL="schacon@example.com";      git commit-tree "$@";        else        fi' HEAD</code></pre><h3 id="详细参数："><a href="#详细参数：" class="headerlink" title="详细参数："></a>详细参数：</h3><ul><li><p><code>--tree-filter </code>表示修改文件列表</p></li><li><p><code>--msg-filter </code>表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出</p></li><li><p><code>--commit-filter</code> 针对提交信息进行修改</p></li><li><p><code>--prune-empty </code>表示如果修改后的提交为空则扔掉不要。</p></li><li><p><code>-f</code>是忽略备份。不加这个选项第二次运行这个命令时会出错，意思是 git 上次做了备份，现在再要运行的话得处理掉上次的备份。</p></li><li><p><code>--all</code>是针对所有的分支。</p></li></ul><pre><code>  [^依云：初次使用 git 的“核弹级选项”：filter-branch]: https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html</code></pre><pre><code>title: 忘记该忘记的，记住该记住的 —— git filter-branchdate: 2020-12-01 22:00:00categories: 工具tags: gitimg: ../../coverImages/git.jpgtypora-root-url: ../../images</code></pre><p>Pro git 中把 <code>filter-branch</code> 称为 <strong>核弹</strong>，让人难以忘记，也充分说明了该命令的威力。</p><h3 id="问题场景-1"><a href="#问题场景-1" class="headerlink" title="问题场景"></a>问题场景</h3><ol><li>在你的开源仓库中提交了，一个数据库的配置文件。</li><li>同事在仓库中把 <code>node_modules</code>目录提交到仓库中，并且这个目录还被后续更新过。</li></ol><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>可以使用<code>filter-branch</code>实现上述需求。</p><p>从每一个提交移除一个文件：</p><pre><code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEADgit filter-branch --tree-filter &#39;rm -rf node_modules&#39; HEADgit filter-branch --tree-filter &#39;rm -rf node_modules&#39; HEAD~30..HEADgit filter-branch --commit-filter &#39;    if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];    then      GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;      GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;      git commit-tree &quot;$@&quot;;    else    fi&#39; HEAD</code></pre><ul><li><p><code>--tree-filter</code>表示修改文件列表</p></li><li><p><code>--msg-filter</code>表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出</p></li><li><p><code>--commit-filter</code> 针对提交信息进行修改</p></li><li><p><code>--prune-empty</code>表示如果修改后的提交为空则扔掉不要。</p></li><li><p><code>-f</code>是忽略备份。不加这个选项第二次运行这个命令时会出错，意思是 git 上次做了备份，现在再要运行的话得处理掉上次的备份。</p></li><li><p><code>--all</code>是针对所有的分支。</p><p>[[<strong><a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener">https://git-scm.com/docs/git-filter-branch</a></strong>] ] 官方文档</p><p>[[<strong>依云：初次使用 git 的“核弹级选项”：filter-branch</strong>] ] <a href="https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html" target="_blank" rel="noopener">https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html</a></p></li></ul><h3 id="详细参数：-1"><a href="#详细参数：-1" class="headerlink" title="详细参数："></a>详细参数：</h3><p>全局修改邮箱地址：</p><p>限制移除范围：</p><p>从每一个提交移除一个目录：</p><pre><code>title: 忘记该忘记的，记住该记住的 —— git filter-branchdate: 2020-12-01 22:00:00categories: 工具tags: gitimg: ../../coverImages/git.jpgtypora-root-url: ../../images</code></pre><p>Pro git 中把 <code>filter-branch</code> 称为 <strong>核弹</strong>，让人难以忘记，也充分说明了该命令的威力。</p><h3 id="问题场景-2"><a href="#问题场景-2" class="headerlink" title="问题场景"></a>问题场景</h3><ol><li>在你的开源仓库中提交了，一个数据库的配置文件。</li><li>同事在仓库中把 <code>node_modules</code>目录提交到仓库中，并且这个目录还被后续更新过。</li></ol><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>可以使用<code>filter-branch</code>实现上述需求。</p><p>从每一个提交移除一个文件：</p><pre><code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEADgit filter-branch --tree-filter &#39;rm -rf node_modules&#39; HEADgit filter-branch --tree-filter &#39;rm -rf node_modules&#39; HEAD~30..HEADgit filter-branch --commit-filter &#39;    if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];    then      GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;      GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;      git commit-tree &quot;$@&quot;;    else    fi&#39; HEAD</code></pre><ul><li><p><code>--tree-filter</code>表示修改文件列表</p></li><li><p><code>--msg-filter</code>表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出</p></li><li><p><code>--commit-filter</code> 针对提交信息进行修改</p></li><li><p><code>--prune-empty</code>表示如果修改后的提交为空则扔掉不要。</p></li><li><p><code>-f</code>是忽略备份。不加这个选项第二次运行这个命令时会出错，意思是 git 上次做了备份，现在再要运行的话得处理掉上次的备份。</p></li><li><p><code>--all</code>是针对所有的分支。</p><p>[[<strong><a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener">https://git-scm.com/docs/git-filter-branch</a></strong>] ] 官方文档</p><p>[[<strong>依云：初次使用 git 的“核弹级选项”：filter-branch</strong>] ] <a href="https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html" target="_blank" rel="noopener">https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html</a></p></li></ul><h3 id="详细参数：-2"><a href="#详细参数：-2" class="headerlink" title="详细参数："></a>详细参数：</h3><p>全局修改邮箱地址：</p><p>限制移除范围：</p><p>从每一个提交移除一个目录：</p><pre><code>title: 忘记该忘记的，记住该记住的 —— git filter-branchdate: 2020-12-01 22:00:00categories: 工具tags: gitimg: ../../coverImages/git.jpgtypora-root-url: ../../images</code></pre><p>Pro git 中把 <code>filter-branch</code> 称为 <strong>核弹</strong>，让人难以忘记，也充分说明了该命令的威力。</p><h3 id="问题场景-3"><a href="#问题场景-3" class="headerlink" title="问题场景"></a>问题场景</h3><ol><li>在你的开源仓库中提交了，一个数据库的配置文件。</li><li>同事在仓库中把 <code>node_modules</code>目录提交到仓库中，并且这个目录还被后续更新过。</li></ol><h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>可以使用<code>filter-branch</code>实现上述需求。</p><p>从每一个提交移除一个文件：</p><pre><code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEADgit filter-branch --tree-filter &#39;rm -rf node_modules&#39; HEADgit filter-branch --tree-filter &#39;rm -rf node_modules&#39; HEAD~30..HEADgit filter-branch --commit-filter &#39;    if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];    then      GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;      GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;      git commit-tree &quot;$@&quot;;    else    fi&#39; HEAD</code></pre><ul><li><p><code>--tree-filter</code>表示修改文件列表</p></li><li><p><code>--msg-filter</code>表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出</p></li><li><p><code>--commit-filter</code> 针对提交信息进行修改</p></li><li><p><code>--prune-empty</code>表示如果修改后的提交为空则扔掉不要。</p></li><li><p><code>-f</code>是忽略备份。不加这个选项第二次运行这个命令时会出错，意思是 git 上次做了备份，现在再要运行的话得处理掉上次的备份。</p></li><li><p><code>--all</code>是针对所有的分支。</p><p>[[[<strong><a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener">https://git-scm.com/docs/git-filter-branch</a></strong>] ] ] 官方文档</p><p>[[[<strong>依云：初次使用 git 的“核弹级选项”：filter-branch</strong>] ] ] <a href="https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html" target="_blank" rel="noopener">https://blog.lilydjwg.me/2011/4/22/tried-the-nuclear-option-filter-branch-of-git-the-first-time.26331.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重置过去，面向未来 —— git rebase</title>
      <link href="/2020/11/30/tool/git-rebase/"/>
      <url>/2020/11/30/tool/git-rebase/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git rebase 是一个危险的操作，如果不能熟练掌握，请不要使用它。（它并不是不可或缺的）</p></blockquote><p><code>git rebase</code> 是一个平常使用较少的一个命令，这次准备分享 git ，把一系列不常用的 git 命令，都熟悉一下。简单明了，不深究原理，只面向解决问题。</p><h3 id="场景一：合并多次提交"><a href="#场景一：合并多次提交" class="headerlink" title="场景一：合并多次提交"></a>场景一：合并多次提交</h3><p>本地开发，存在多次提交记录，需要合并提交，方便查看。</p><pre class=" language-shell"><code class="language-shell">commit 36bf7ff90f1cf33991cc68dac8e078c3f6e14ca3 (HEAD -> master)Date:   Mon Nov 30 21:17:25 2020 +0800    add 2.txtcommit 1569f1e8dfa9bca26e0233780a43e0961209ad8cDate:   Mon Nov 30 21:17:12 2020 +0800    add 1.txt</code></pre><ol><li><p>列出本地最近记录</p><pre class=" language-shell"><code class="language-shell">git rebase -i HEAD~2</code></pre></li><li><p>这时候会进入 <code>vi</code>模式</p><pre class=" language-shell"><code class="language-shell">pick 60b798f add a bpick d39bbcd add 1.txt add 2.txt# 变基 8a749eb..d39bbcd 到 8a749eb（2 个提交）## 命令:# p, pick <提交> = 使用提交# r, reword <提交> = 使用提交，但修改提交说明# e, edit <提交> = 使用提交，进入 shell 以便进行提交修补# s, squash <提交> = 使用提交，但融合到前一个提交# f, fixup <提交> = 类似于 "squash"，但丢弃提交说明日志# x, exec <命令> = 使用 shell 运行命令（此行剩余部分）# b, break = 在此处停止（使用 'git rebase --continue' 继续变基）# d, drop <提交> = 删除提交# l, label <label> = 为当前 HEAD 打上标记# t, reset <label> = 重置 HEAD 到该标记# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]# .       创建一个合并提交，并使用原始的合并提交说明（如果没有指定# .       原始提交，使用注释部分的 oneline 作为提交说明）。使用# .       -c <提交> 可以编辑提交说明。## 可以对这些行重新排序，将从上至下执行。</code></pre><p>vi 模式修改 <code>pick</code> 保存之后，就可以实现合并提交记录。</p><p><strong>注意：</strong>第一行<code>pick 60b798f add a b</code>不能是<code>s</code>，可以是<code>pick</code>或者<code>reword</code>。合并必须有一个基点，第一行就是一个基点，后续的变更合并都必须有第一行这个可合并的对象存在。</p></li><li><p>如果退出了 <code>vi</code>窗口，想要继续编辑：</p><pre class=" language-shell"><code class="language-shell">git rebase --edit-todo</code></pre></li></ol><h3 id="场景二：分支合并"><a href="#场景二：分支合并" class="headerlink" title="场景二：分支合并"></a>场景二：分支合并</h3><p><code>git merge</code> 和 <code>git rebase</code> 都可以实现分支合并。</p><p>git merge,合并之后，存在多个分支线。</p><p>![image-20201130215051796](/../../../../../Library/Application Support/typora-user-images/image-20201130215051796.png)</p><p>git rebase 合并之后，也就是上图的 <code>develop add 3.txt</code>并不会产生新的合并记录，详细过程如下：</p><ol><li><p>首先，<code>git</code> 会把 <code>develop</code> 分支里面的每个 <code>commit</code> 取消掉；</p></li><li><p>其次，把上面的操作临时保存成 <code>patch</code> 文件，存在 <code>.git/rebase</code> 目录下；</p></li><li><p>然后，把 <code>develop</code> 分支更新到最新的 <code>master</code> 分支；</p></li><li><p>最后，把上面保存的 <code>patch</code> 文件应用到 <code>develop</code> 分支上；</p><p>这也就是 <code>git rebase</code>为什么被称为 **变基 **的原因，随着主分支的发展，变基操作，只是同步了主分支的更改，在最新的主分支上面进行开发。有点类似 <code>git stash</code>, 先保存内容，等分支同步之后，再释放内容。</p></li></ol><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>因为变基操作会直接修改历史记录，千万不要在公共分支上面使用变基操作，你应该只在你自己的分支上进行<code>git rebase</code>操作。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 月的碎碎念</title>
      <link href="/2020/11/29/anything/jscoder/"/>
      <url>/2020/11/29/anything/jscoder/</url>
      
        <content type="html"><![CDATA[<ol><li><p>启用 jscoder.com 域名</p><p>一直对现在的域名（aocoding.com）不是非常满意，但是又没有合适的域名。最近把 jscoder.com 续费10年，长期使用。希望自己多多努力，产出文章，不负自己的 money 投入。</p></li><li><p>购入 4c8g5m 机器</p><p>前期的两台1c2g1m 小机器，给我带来了不少的快乐，然而，性能越来越满足不了我的需要。我想试试docker，想试试资源本地部署，不走cdn，这些小机器都无法满足。</p><p>现在小机器上面跑了1个爬虫，api 服务，每次ssh部署 node 服务就难受，要等待好久。</p><p>现在大机器上，部署docker，node 都很快，不要把生命浪费在等待上，该换就换，该升级就升级。机器价值是有限的，而你提供的服务是无价的：）</p></li><li><p>学习 docker</p><p>docker 大法好，docker 大法妙，docker 呱呱叫。</p><p>然鹅，部署项目时候，还是选择了宝塔面板，实在是太易用了…不要考虑那么多，无脑操作，项目就部署好了。待我 docker 再好好学一学，再考虑直接换成 docker 咯….</p><p>k8s 实在是太复杂了，项目搭建都一堆问题搞不定，算啦算啦，现在 docker-compose 已经能满足我的需求了。</p></li><li><p>miAxios 经历项目考验</p><p>封装的小程序请求库  <a href="https://github.com/Yaob1990/miniAxios#readme" target="_blank" rel="noopener">miniAxios</a>  在支付宝小程序项目中运行良好，没有严重bug。</p><p>request 库的封装，参考了 axios，axios ts 教程，等等内容，封装虽然没有什么技术含量，自己还是学到了很多东西，加深了对 ts 的理解。</p><p>后续计划：</p><ol><li>加强对多平台的支持，目前虽然是支持多平台的，但是我自己也没有完整测试过=-=。</li><li>加强 ts 类型判断，目前的 ts 在 Response 部分还是有点问题。</li><li>统一返回参数。目前的 response 是根据返回报文直接返回，后续，会归集到 response 的 data 下面，类似： res.config.data 的结构</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编码点滴 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue3 h5 脚手架</title>
      <link href="/2020/09/21/front-end/vue3-h5/"/>
      <url>/2020/09/21/front-end/vue3-h5/</url>
      
        <content type="html"><![CDATA[<p>vue 3 终于发布了正式版。</p><p>也把自己用了很久的 h5 脚手架更新了一波，所有依赖都升级到最新，后续h5开发就直接使用最新的脚手架进行开发。</p><p>后续还会增加多页面的脚手架，多页面写的真的不多，但是配置还是有点意思的~</p><p>本次脚手架，抛弃了单元测试，业务太多，真的写不过来=-=</p><p>Node-sass 换成了less，不多说，懂得自然懂….</p><p>地址：<a href="https://github.com/Yaob1990/vue3-h5" target="_blank" rel="noopener">https://github.com/Yaob1990/vue3-h5</a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><pre><code>  1. 集成最新 `vue` 全家桶，使用 `typescript` 开发  2. 路由使用 hash 模式，方便部署  3. `axios` 封装，暴露常用的 `get` `post` 方法  4. `axios` 封装，避免多重 `loading` 的问题，并提供接口配置项  5. 使用 less ，提供基础的`mixin`，并作为全局css，方便使用  6. 异步加载 `vconsole`，线上环境，无需手动去除，不会打入主包，不会引起包体积增大  7. ui 框架选择 `vant`，按需引入  8. `npm run report` 分析构建包的大小  9. 线上版本去除 console.log，debugger 等调试内容</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>herbjs 简明数据流</title>
      <link href="/2020/08/16/front-end/leran-herbjs/"/>
      <url>/2020/08/16/front-end/leran-herbjs/</url>
      
        <content type="html"><![CDATA[<p>最近在使用<code>herbjs</code>做支付宝小程序的开发，在熟悉了开发模式之后，还是挺好用的。</p><h3 id="小程序运行机制"><a href="#小程序运行机制" class="headerlink" title="小程序运行机制"></a>小程序运行机制</h3><p>写小程序的感觉，更像是在写ract，然而这两者的机制是不一样的。</p><p>小程序的框架包含两部分View视图层(可能存在多个)、App Service逻辑层(一个)，View层用来渲染页面结构，AppService层用来逻辑处理、数据请求、接口调用，它们在两个线程里运行。</p><p>视图层使用WebView渲染，逻辑层使用JSCore运行。</p><p>视图层和逻辑层通过系统层的JsBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。</p><img src="/images/image-20200816164049483.png" alt="image-20200816164049483" style="zoom:50%;" /><p>小程序的<code>setData</code>并不是实时的，而是需要两个线程通过 <code>JsBridge</code> 进行通信完成，在性能优化方面，需要考虑：</p><ol><li>避免频繁的 <code>setData</code>，容易造成卡顿，渲染出现延迟</li><li>避免<code>setData</code>频繁传递大量数据</li><li>避免后台页面<code>setData</code>,用户无法感知，会抢占前台页面的执行</li></ol><h3 id="herbjs-与原生开发框架相比"><a href="#herbjs-与原生开发框架相比" class="headerlink" title="herbjs 与原生开发框架相比"></a>herbjs 与原生开发框架相比</h3><p>原生框架数据以page为单位，进行管理。</p><p>herbjs 吸收了 vuex 的精华，给小程序增加了，全局 store，页面store，等一系列的 vuex 功能。还支持 <code>typescript</code>,<code>插件体系</code>等功能。</p><p>区别于 <code>uni-app</code>,<code>taro</code>,这些框架，herbjs 并没有修改小程序本身的逻辑，原有的生命周期都还在，原有的写法也都适用，更多的可以看成是原生小程序的增强版。</p><p>个人觉得，<code>简明的数据流</code>是这个框架最优雅的地方，方便大量 vue 开发者快速上手开发。</p><p>官方文档: <a href="https://www.yuque.com/herbjs/doc" target="_blank" rel="noopener">https://www.yuque.com/herbjs/doc</a></p><p>官方文档，其实说的已经比较明白了，值得多看几遍。</p><h3 id="简明数据流"><a href="#简明数据流" class="headerlink" title="简明数据流"></a>简明数据流</h3><p>项目地址：<a href="https://github.com/Yaob1990/leran_herbjs" target="_blank" rel="noopener">https://github.com/Yaob1990/leran_herbjs</a></p><h4 id="页面级别数据流"><a href="#页面级别数据流" class="headerlink" title="页面级别数据流"></a>页面级别数据流</h4><p>页面中，通过 <code>setData</code>数据</p><pre class=" language-typescript"><code class="language-typescript">Page<span class="token operator">&lt;</span>IPageState<span class="token punctuation">,</span> IPageMethods<span class="token punctuation">,</span> IPageStore<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">onLoad</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">plus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      num<span class="token punctuation">:</span> <span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>num<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">minus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      num<span class="token punctuation">:</span> <span class="token operator">--</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>num<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="组件中数据流"><a href="#组件中数据流" class="headerlink" title="组件中数据流"></a>组件中数据流</h4><p>外部传入参数，注意如果是监听事件必须是<code>on</code>开头</p><pre class=" language-typescript"><code class="language-typescript">Component<span class="token operator">&lt;</span>IComponentData<span class="token punctuation">,</span> IComponentProps<span class="token punctuation">,</span> IComponentMethods<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">{</span>  mapStateToData<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    text<span class="token punctuation">:</span> <span class="token string">'component'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>    onPlus<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    onMinus<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">didMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">didUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">plus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onPlus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">minus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onMinus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>组件使用：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name">onPlus</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>plus<span class="token punctuation">"</span></span> <span class="token attr-name">onMinus</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>minus<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>action</span><span class="token punctuation">></span></span></code></pre><h4 id="页面-store-数据流"><a href="#页面-store-数据流" class="headerlink" title="页面 store 数据流"></a>页面 store 数据流</h4><pre class=" language-typescript"><code class="language-typescript">Page<span class="token operator">&lt;</span>IPageData<span class="token punctuation">,</span> IPageMethods<span class="token punctuation">,</span> IPageStore<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">plus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'plus'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">minus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'minus'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'multiplyAsync'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>store 部分</p><pre class=" language-typescript"><code class="language-typescript">Store<span class="token operator">&lt;</span>IPageState<span class="token punctuation">,</span> IPageGetters<span class="token punctuation">,</span> IPageMutations<span class="token punctuation">,</span> IPageActions<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 全局 Getter 可以被 App、Page、Component 都能访问到</span>  <span class="token comment" spellcheck="true">// 页面 Getter 只能被当前 Page 和 当前 Page 内的 Component 访问到</span>  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>    desc<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> state<span class="token punctuation">,</span> getters <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'正值'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'负值'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'零'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">plus</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token operator">++</span>state<span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">minus</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token operator">--</span>state<span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">multiply</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>num <span class="token operator">=</span> state<span class="token punctuation">.</span>num <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>    async <span class="token function">multiplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">{</span> state<span class="token punctuation">,</span> commit<span class="token punctuation">,</span> dispatch <span class="token punctuation">}</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'multiply'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="全局-store"><a href="#全局-store" class="headerlink" title="全局 store"></a>全局 store</h4><p>全局 store 和页面类似，只是多一个 <code>$global</code>参数，详见文档。</p><h3 id="开发体会"><a href="#开发体会" class="headerlink" title="开发体会"></a>开发体会</h3><p>小程序的开发框架百花齐放，uni-app，taro，mpvue。</p><p>然而，自己也只是停留在会用的程度，没有再去想一想为什么可以这样编译，内部的原理。这阶段的工作估计会长期和小程序打交道，希望自己能够深入的研究小程序的背后逻辑，而不仅仅会用就行。</p><p>道阻且长，同志加油。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 支付宝小程序,herbjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async await 的终极封装</title>
      <link href="/2020/08/06/front-end/async-await/"/>
      <url>/2020/08/06/front-end/async-await/</url>
      
        <content type="html"><![CDATA[<h2 id="async-await-的终极封装"><a href="#async-await-的终极封装" class="headerlink" title="async await 的终极封装"></a>async await 的终极封装</h2><p>在看同事代码时候，看到下面这一段，有点意思。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> <span class="token punctuation">[</span>res<span class="token punctuation">,</span>error<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 错误处理</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 业务处理</span></code></pre><p>注意，这里代码没有使用try catch，而是把错误处理封装成了数组形式。</p><p>继续，看看他的代码是怎么写的：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">promieWapper</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">[</span>res<span class="token punctuation">,</span> undefined<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">[</span>undefined<span class="token punctuation">,</span> err<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>getList <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">promieWapper</span><span class="token punctuation">(</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看起来也不是很复杂，就是在promise 外面在套一层promise，返回结果，放到一个数组中。</p><p>很巧妙的实现了，错误的处理，使用时候，直接进行数组的判断，不需要去写丑陋的 try catch</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>仔细看一下上面的代码，其实有点小问题，内部返回的就是promise，还有必要再嵌套一层 promise ？</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">promieWapper</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span>res<span class="token punctuation">,</span> undefined<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      retirn <span class="token punctuation">[</span>undefined<span class="token punctuation">,</span> err<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这样写感觉更清爽一点， then 返回的部分也还是 promise，异常也会被 catch 捕获到。</p><h2 id="添加函数类型（ts）"><a href="#添加函数类型（ts）" class="headerlink" title="添加函数类型（ts）"></a>添加函数类型（ts）</h2><pre class=" language-typescript"><code class="language-typescript">async <span class="token keyword">function</span> promieWapper<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U <span class="token operator">=</span> Error<span class="token operator">></span><span class="token punctuation">(</span>promise<span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token punctuation">[</span>U<span class="token punctuation">,</span> undefined<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">,</span> T<span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> promise<span class="token punctuation">.</span>then<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">,</span> T<span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">,</span> data<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token operator">&lt;</span><span class="token punctuation">[</span>U<span class="token punctuation">,</span> undefined<span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">:</span> U<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> undefined<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>node 中一般 Error 会放在第一个参数位置，这里参考 node 优先处理错误。</p><h2 id="3年前…"><a href="#3年前…" class="headerlink" title="3年前…"></a>3年前…</h2><p>我觉得我同事牛逼极了，能想出这么天才的方法！</p><p>直到我看到了这个库：<a href="https://github.com/scopsy/await-to-js" target="_blank" rel="noopener">await-to-js</a></p><p>上面的最终写法，也是参考了这个库。这个库 2.3m/month 的下载量，还是3年前写的，写好基本没有更新过，真牛逼！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丰云行app 探索</title>
      <link href="/2020/06/17/front-end/fyx/"/>
      <url>/2020/06/17/front-end/fyx/</url>
      
        <content type="html"><![CDATA[<p>广汽丰田的风云行app，提供的车联网功能还是挺好用的，但是只能提供车辆的位置信息，不能提供行驶轨迹等功能。于是抓包看了下他的功能逻辑。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 登录地址（post）：</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>carapp<span class="token punctuation">.</span>gtmc<span class="token punctuation">.</span>com<span class="token punctuation">.</span>cn<span class="token operator">/</span>api<span class="token operator">/</span>appgtmc<span class="token operator">/</span>reg<span class="token operator">/</span>action<span class="token operator">/</span>AppUserInfoAction<span class="token operator">/</span>appUserLogin<span class="token punctuation">.</span>json<span class="token comment" spellcheck="true">// 参数（body）</span>accessToken<span class="token operator">=</span><span class="token operator">&amp;</span>appVersion<span class="token operator">=</span><span class="token number">4.3</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&amp;</span>checkCode<span class="token operator">=</span><span class="token operator">&amp;</span>deviceId<span class="token operator">=</span><span class="token operator">&amp;</span>deviceType<span class="token operator">=</span><span class="token number">2</span><span class="token operator">&amp;</span>distinctId<span class="token operator">=</span><span class="token operator">&amp;</span>loginType<span class="token operator">=</span><span class="token number">2</span><span class="token operator">&amp;</span>password<span class="token operator">=</span><span class="token operator">&amp;</span>phoneName<span class="token operator">=</span><span class="token operator">&amp;</span>phoneNumber<span class="token operator">=</span><span class="token operator">&amp;</span>pushId<span class="token operator">=</span></code></pre><p>返回值：</p><pre><code>{    &quot;data&quot;: {        &quot;jwt&quot;: &quot;&quot;,        &quot;rData&quot;: {            &quot;birthday&quot;: &quot;&quot;,            &quot;passWord&quot;: &quot;111&quot;,            &quot;communtiyFlag&quot;: &quot;0&quot;,            &quot;dealerName&quot;: &quot;&quot;,            &quot;address&quot;: &quot;&quot;,            &quot;kickOut&quot;: true,            &quot;dealerCode&quot;: &quot;&quot;,            &quot;sex&quot;: &quot;null&quot;,            &quot;resultCode&quot;: &quot;&quot;,            &quot;description&quot;: &quot;&quot;,            &quot;userId&quot;: 111,            &quot;uuid&quot;: &quot;111&quot;,            &quot;telPhone&quot;: &quot;111&quot;,            &quot;name&quot;: &quot;1&quot;,            &quot;status&quot;: &quot;0&quot;,            &quot;username&quot;: &quot;11&quot;        }    },    &quot;success&quot;: true,    &quot;resultCode&quot;: 200,    &quot;elapsedMilliseconds&quot;: 0}</code></pre><p>jwt 就是登录凭证，有了这个登录凭证后续的请求都可以进行鉴权。</p><p>这里后端返回了<code>passWord</code>字段，个人觉得非常不合适。后端要么是直接返回的用户数据，要么就没有做非对称加密，直接数据库解码出用户的密码字段！通过网络劫持，很容易就嗅探出用户的密码了。</p><p>给广汽的邮箱和微信反应过这个问题，没有得到任何回应….</p><h3 id="控制密码校验"><a href="#控制密码校验" class="headerlink" title="控制密码校验"></a>控制密码校验</h3><pre><code>// get 请求https://carapp.gtmc.com.cn/api/vhcApp/controlpwd/checkControlPwd?phone=&amp;pwd=// header Authorization:{{jwt}}</code></pre><p>通过用户的手机号码和控制密码,jwt校验,进行用户身份识别.</p><p>返回:</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"resultCode"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>    <span class="token string">"errMsg"</span><span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    <span class="token string">"elapsedMilliseconds"</span><span class="token punctuation">:</span> <span class="token number">35</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token string">"1"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"success"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p><code>code:1</code> 校验通过,经过测试,这个校验状态的有效期约为三分钟</p><h3 id="获取车辆位置"><a href="#获取车辆位置" class="headerlink" title="获取车辆位置"></a>获取车辆位置</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// get 请求(vin 是车架号码)</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>carapp<span class="token punctuation">.</span>gtmc<span class="token punctuation">.</span>com<span class="token punctuation">.</span>cn<span class="token operator">/</span>api<span class="token operator">/</span>vhcApp<span class="token operator">/</span>lookForCar<span class="token operator">/</span>fixedPosition<span class="token operator">?</span>vin<span class="token operator">=</span><span class="token comment" spellcheck="true">// header </span>Authorization<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>jwt<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>返回结构:</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"resultCode"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>    <span class="token string">"errMsg"</span><span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    <span class="token string">"elapsedMilliseconds"</span><span class="token punctuation">:</span> <span class="token number">1009</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"remissId"</span><span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>        <span class="token string">"latitude"</span><span class="token punctuation">:</span> <span class="token string">"100"</span><span class="token punctuation">,</span>        <span class="token string">"being"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token string">"longitude"</span><span class="token punctuation">:</span> <span class="token string">"200"</span><span class="token punctuation">,</span>        <span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"success"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p>其中 latitude longitude 就是车辆的经纬度了.</p><h3 id="位置上报"><a href="#位置上报" class="headerlink" title="位置上报"></a>位置上报</h3><p>以上的信息似乎就可以获取车辆的位置信息,画出行驶轨迹了。</p><p>然后，我在车辆行驶中时候抓包时候，发现车辆的位置一直是上一次停车的那个点。推测，车辆位置并不是实时上报，而是车辆停止，熄火后上报一次，功能也只用来追踪车辆的最终停止位置。</p><h3 id="还能做什么"><a href="#还能做什么" class="headerlink" title="还能做什么"></a>还能做什么</h3><p>抓包研究的过程还是非常有意思的。虽然我们最初的结果没有达到，但是我们用这些数据依然可以做很多有意思的事情，比如用<code>flutter</code>把这些功能重写一遍？</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 该不该学？</title>
      <link href="/2020/06/02/front-end/learntypescript/"/>
      <url>/2020/06/02/front-end/learntypescript/</url>
      
        <content type="html"><![CDATA[<h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>all in js，编程语言的相互编译并不是复杂的问题，在<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS" target="_blank" rel="noopener">github</a>上面可以看到大量的编译器，<code>java</code>，<code>ruby</code>，<code>python</code>，甚至远古的 <code>smallTalk</code>，<code>lisp</code>，都可以编译为<code> javascript</code>。</p><p><code>javascript</code> 的方言派系大致可以分成两派：</p><ol><li><code>CoffeeScript</code> ：由ruby社区创建的方言，<code>CoffeeScript</code> 吸收了 <code>Ruby</code>, <code>Python</code>, <code>Haskell</code> 语言的设计思想, 将 <code>JavaScript</code> 的代码变得清晰简洁, 盛极一时。</li><li>TypeScript 是 Microsoft 推出的编程语言, 项目由大名鼎鼎的 C# 首席架构师 Anders Hejlsberg 操刀. 它的特点是在 JavaScript 的基础上实现了强类型和静态类型检查, 加入了很多静态语言才有的概念。</li></ol><p><code>CoffeeScript </code>已然式微，Typescript 背靠微软这颗大树，在前端界掀起腥风血雨，知名的开源框架，<code>React</code>、<code>Vue</code>、<code>Angular</code>无不投入其怀抱，甚至<code>github</code>上面稍微用户多一点的类库，都会有 issue 提到是否提供 Typescript 的  <code>.d.ts</code> 文件（有这个文件，就提供了 <code>Typescript</code>的支持 ）。</p><p>官方说，<code>Typescript</code> 是<code>Javascript</code>的超集，似乎可以把他理解成基于 <code>Javascript</code> 的独立语言？我并不这么理解，<code>Typescript</code> 最终的执行宿主环境，还是v8引擎，它最终还是要编译成<code>JavaScript</code>。它的用户绝大部分也还是<code>JavaScript</code>用户，这些原因，使得它对新特性的添加非常克制，新特性几乎都可以在TC39（一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成，制定ECMAScript标准，标准生成的流程，并实现）中找到原型。</p><p><code>Typescript</code> 只不过是 <code>Beta</code> 版本的 <code>Javascript</code>。学不学完全不是问题了，现在不学，以后肯定还是要学:smile:。</p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h3 id="一句-web端-（-基于-vue-和-Typescript-写法）"><a href="#一句-web端-（-基于-vue-和-Typescript-写法）" class="headerlink" title="一句 web端 （ 基于 vue 和 Typescript 写法）"></a><a href="https://word.aocoding.com/" target="_blank" rel="noopener">一句 web端</a> （ 基于 <code>vue</code> 和 Typescript 写法）</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token operator">&lt;</span>script lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">></span><span class="token comment" spellcheck="true">// class 组件写法</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Vue <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue-property-decorator'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Mutation <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex-class'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> message <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'ant-design-vue'</span><span class="token comment" spellcheck="true">// 装饰器</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">IndexPage</span> <span class="token keyword">extends</span> <span class="token class-name">Vue</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 原data</span>  form <span class="token operator">=</span> <span class="token punctuation">{</span>    word<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    <span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    source<span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// vuex state</span> <span class="token comment" spellcheck="true">// ! 断言不为空，兼容写法（断言）</span>  <span class="token comment" spellcheck="true">//  由于Ts最新版本使用了strictPropertyInitialization，如果变量没有在构造函数中使用或赋值，都需要添加!，进行显式赋值断言</span>  @<span class="token function">Mutation</span><span class="token punctuation">(</span><span class="token string">'showloading'</span><span class="token punctuation">)</span> showloading<span class="token operator">!</span><span class="token punctuation">:</span> <span class="token keyword">boolean</span>  rules <span class="token operator">=</span> <span class="token punctuation">{</span>    word<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        required<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'请输入内容'</span><span class="token punctuation">,</span>        whitespace<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>        trigger<span class="token punctuation">:</span> <span class="token string">'blur'</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        required<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'请输入来源'</span><span class="token punctuation">,</span>        whitespace<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>        trigger<span class="token punctuation">:</span> <span class="token string">'blur'</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 兼容写法</span><span class="token comment" spellcheck="true">// nuxt 中$api被挂载到了this下面</span>  $api<span class="token punctuation">:</span> <span class="token keyword">any</span>  <span class="token comment" spellcheck="true">// 兼容写法</span>  <span class="token comment" spellcheck="true">// formRef 类型</span>  <span class="token comment" spellcheck="true">// 解释：https://stackoverflow.com/questions/52109471/typescript-in-vue-property-validate-does-not-exist-on-type-vue-element</span>  <span class="token keyword">get</span> <span class="token function">formRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Vue <span class="token operator">&amp;</span> <span class="token punctuation">{</span> validate<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>form as Vue <span class="token operator">&amp;</span> <span class="token punctuation">{</span> validate<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> async <span class="token function">onSubmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">const</span> verify<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>formRef<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>verify<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span> code<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> await self<span class="token punctuation">.</span>$api<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>form        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'添加成功'</span><span class="token punctuation">)</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>form <span class="token operator">=</span> <span class="token punctuation">{</span>            word<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>            <span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>            source<span class="token punctuation">:</span> <span class="token string">''</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>github:    <a href="https://github.com/justOneWord/one_word_web" target="_blank" rel="noopener">https://github.com/justOneWord/one_word_web</a></p><p>个人感受：</p><ol><li>传统vue组件写法过度为<code>vue-class-component</code>写法，改变比较大，使用装饰器代替传统的代码组织形式。</li><li>因为对Typescript的支持不完善，需要写部分兼容代码。</li><li>前端的代码类库提供的类型定义文件不完善，很多类库都没有提供，部分表态在vue3之后提供。现阶段可能需要手动声明为any使用。</li></ol><h3 id="一句服务端-（基于-nest-js-和-typescript-写法）"><a href="#一句服务端-（基于-nest-js-和-typescript-写法）" class="headerlink" title="一句服务端 （基于 nest.js 和 typescript 写法）"></a>一句服务端 （基于 nest.js 和 typescript 写法）</h3><p><code>wordController</code>(部分)：</p><p>大量使用装饰器语法，简化写法</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 装饰器</span>@<span class="token function">Controller</span><span class="token punctuation">(</span><span class="token string">'word'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">WordController</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> readonly wordService<span class="token punctuation">:</span>WordService<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 三个装饰器</span>  @<span class="token function">Post</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 参数校验管道</span>  @<span class="token function">UsePipes</span><span class="token punctuation">(</span>ValidationPipe<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 手动返回200，否则会返回201，也可以放到全局拦截器去做</span>  @<span class="token function">HttpCode</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// body 类型 WordDto</span>  async <span class="token function">add</span><span class="token punctuation">(</span>@<span class="token function">Body</span><span class="token punctuation">(</span><span class="token punctuation">)</span> body<span class="token punctuation">:</span> WordDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>   await <span class="token keyword">this</span><span class="token punctuation">.</span>wordService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  @<span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">'random'</span><span class="token punctuation">)</span>  random <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wordService<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>wordService</code>（部分）:</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">constructor</span><span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">// 注入 redis</span>    <span class="token keyword">private</span> readonly redisService<span class="token punctuation">:</span> RedisService<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 数据库注入</span>    @<span class="token function">InjectRepository</span><span class="token punctuation">(</span>Word<span class="token punctuation">)</span> <span class="token keyword">private</span> readonly wordReposition<span class="token punctuation">:</span> Repository<span class="token operator">&lt;</span>Word<span class="token operator">></span><span class="token punctuation">,</span>    @<span class="token function">InjectRepository</span><span class="token punctuation">(</span>Hitoapi<span class="token punctuation">)</span>    <span class="token keyword">private</span> readonly hitoApiReposition<span class="token punctuation">:</span> Repository<span class="token operator">&lt;</span>Hitoapi<span class="token operator">></span><span class="token punctuation">,</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 指定 body 类型为 `WordDto`</span>async <span class="token function">add</span><span class="token punctuation">(</span>body<span class="token punctuation">:</span> WordDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找是否存在</span>    <span class="token comment" spellcheck="true">// result 会自动推导出类型，不需要手动指定</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>wordReposition<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">{</span> word<span class="token punctuation">:</span> body<span class="token punctuation">.</span>word <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ApiCode 代码提示，也是Typescript提供的能力</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApiException</span><span class="token punctuation">(</span><span class="token string">'资源已经存在'</span><span class="token punctuation">,</span> ApiCode<span class="token punctuation">.</span>EXIST_ERROR<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> newWord <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>wordReposition<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token operator">...</span>body<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'newWord'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> newResult <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>wordReposition<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>newWord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//  插入成功</span>      <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApiException</span><span class="token punctuation">(</span><span class="token string">'添加失败'</span><span class="token punctuation">,</span> ApiCode<span class="token punctuation">.</span>BUSINESS_ERROR<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>github: <a href="https://github.com/justOneWord/one_word_api" target="_blank" rel="noopener">https://github.com/justOneWord/one_word_api</a></p><p>个人感受：</p><ol><li><code>nestjs</code> 框架基于 Typescript 开发，整体使用行云流水，没有为了用Typescript而用Typescript的感觉。</li><li>代码层次清晰，具有完善的 mvc 结构，比<code>express</code>方便。</li></ol><p>参考文档：</p><ol><li><p><a href="https://www.blackglory.me/javascript-dialects-and-factions/" target="_blank" rel="noopener">漫谈 JavaScript 方言与派系</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/139731168" target="_blank" rel="noopener">前端开发的瓶颈与未来之路</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webstorm 中调试typescript单文件</title>
      <link href="/2020/05/22/front-end/debugger-typescript-in-webstorm/"/>
      <url>/2020/05/22/front-end/debugger-typescript-in-webstorm/</url>
      
        <content type="html"><![CDATA[<p>leetCode 最近支持了<code>typescript</code>刷题，高高兴兴把<code>webstorm</code>切换到typescript刷题,记录下切换过程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为刷题都是单文件，我们需要用webstorm支持debugger单ts文件。</p><p><code>yarn add typescript ts-node</code>  ts-node 可以让我们直接执行ts文件</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>配置部分 Node parameters 填写：<code>--require ts-node/register</code>。</li><li>点击运行，就可以直接执行<code>.ts</code>单文件，点击debugger就可以进行<code>debugger</code>了，和以前调试js一样，非常方便</li></ol><p><img src="/images/image-20200522110323174.png" alt="配置"></p><p><img src="/images/image-20200522110831517.png" alt="运行"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code-surfer 中文翻译</title>
      <link href="/2020/05/12/translation/code-surfer-zh/"/>
      <url>/2020/05/12/translation/code-surfer-zh/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/pomber/code-surfer" target="_blank" rel="noopener">code-surfer</a>  炫酷的代码演示ppt。</p><p>用起来还是有些小毛病，比如无法居中，要手动条件，但是瑕不掩瑜，这是一款非常棒的软件。</p><p>顺手做了个翻译，已提到官方库。</p><p>和博客的渲染有点冲突，移步官方库，地址：<a href="https://github.com/pomber/code-surfer/blob/master/readme-zh.md" target="_blank" rel="noopener">https://github.com/pomber/code-surfer/blob/master/readme-zh.md</a></p><hr><h1 id="Code-Surfer"><a href="#Code-Surfer" class="headerlink" title="Code Surfer"></a>Code Surfer</h1><blockquote><p>在 <a href="https://opencollective.com/code-surfer" target="_blank" rel="noopener">support</a>  上赞助这个项目，保持她的生命力❤️</p></blockquote><p>Code Surfer为 <a href="https://github.com/jxnblk/mdx-deck" target="_blank" rel="noopener">MDX Deck</a> 幻灯片增加代码高亮、代码缩放、代码滚动、代码聚焦、代码变形等功能。</p><p>创建并运行一个新的项目:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> init code-surfer-deck my-deck<span class="token function">cd</span> my-deck<span class="token function">npm</span> start</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li><a href="https://advanced-graphql-workshop.netlify.com/" target="_blank" rel="noopener">强大的GraphQL工作坊</a> 作者 <a href="https://twitter.com/_philpl" target="_blank" rel="noopener">Phil Pluckthun</a></li><li><a href="https://github.com/pomber/react-conf-2018-hooks-demo" target="_blank" rel="noopener">React Conf 2018 Hooks Demo</a></li></ul><h2 id="如何使用-Code-Surfer"><a href="#如何使用-Code-Surfer" class="headerlink" title="如何使用 Code Surfer"></a>如何使用 Code Surfer</h2><blockquote><p>首先了解 <a href="https://github.com/jxnblk/mdx-deck" target="_blank" rel="noopener">MDX Deck</a> 的工作方式可能会有所帮助</p></blockquote><p>要使用 Code Surfer，你需要先将其导入，并使用 <code>&lt;CodeSurfer&gt;</code> 标签包裹要显示的代码（<strong>需要在代码块之前和之后保留空行</strong>）:</p><pre class=" language-markdown"><code class="language-markdown">import { CodeSurfer } from "code-surfer"<span class="token title important"><span class="token punctuation">#</span> Deck Title</span><span class="token hr punctuation">---</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CodeSurfer</span><span class="token punctuation">></span></span>​```jsconsole.log(1);console.log(2);console.log(3);```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>CodeSurfer</span><span class="token punctuation">></span></span></code></pre><p>特性:</p><ul><li><a href="#focus">高亮</a></li><li><a href="#steps">步骤</a></li><li><a href="#title-and-subtitle">标题和副标题</a></li><li><a href="#themes">主题</a></li><li><a href="#custom-styles">自定义样式</a></li><li><a href="#languages">多语言支持</a></li><li><a href="#columns">列</a></li><li><a href="#import-code">导入代码</a></li><li><a href="#line-numbers">行号</a></li><li><a href="#diffs">差异</a></li></ul><blockquote><p>这是一个 <a href="https://codesurfer.pomb.us/full/" target="_blank" rel="noopener">使用所有功能</a> (及 <a href="https://raw.githubusercontent.com/pomber/code-surfer/code-surfer-v2/sites/docs/decks/full.mdx" target="_blank" rel="noopener">mdx 源码</a>)的演示文稿，万一你更喜欢阅读代码而不是文档😀</p></blockquote><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>在代码块第一行中的（设置）语言之后添加 _高亮字符串位置_，以告诉Code Surfer你要高亮的行和列。</p><p>Code Surfer将淡出所有未高亮的代码，并在必要时将其缩小以适合幻灯片。</p><p>​````md<br><CodeSurfer></p><p>​```js 1:2,3[8:10]<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>&lt;/CodeSurfer&gt;</code></pre><p>在上面的示例中，<code>1:2,3[8:10]</code> 意思是：“行1行2高亮，行3到列8到10高亮”。更多示例：</p><ul><li><code>5:10</code> 第 5,6,7,8,9 行 和第 10 行高亮</li><li><code>1,3:5,7</code> 第1行，第 3~5 行，第 7 行高亮，</li><li><code>2[5]</code> 第 2 行第5高亮</li><li><code>2[5:8]</code> 第 2 行 5~8 列高亮</li><li><code>1,2[1,3:5,7],3</code> 第1行，第2行，第2行第1列、3~5列、7列高亮</li></ul><p><em>注意: 在以前的CodeSurfer版本中，我们使用标记代替列。</em></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>添加更多代码块，以向 Code Surfer 幻灯片添加步骤。</p><p>​````md<br><CodeSurfer></p><p>​```js<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>```js 1console.log(1);console.log(2);console.log(3);</code></pre><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></CodeSurfer>````<p>你可以为不同的步骤更改焦点和/或代码，然后 Code Surfer 会在以下步骤之间进行变换：缩放，滚动，淡入，淡出，添加和删除行。</p><h2 id="标题和副标题"><a href="#标题和副标题" class="headerlink" title="标题和副标题"></a>标题和副标题</h2><p>​````md<br><CodeSurfer></p><p>​```js 1 title=”Title” subtitle=”Look at the first line”<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>```js 2 title=&quot;Title&quot; subtitle=&quot;and now the second&quot;console.log(1);console.log(2);console.log(3);</code></pre></CodeSurfer>````<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://codesurfer.pomb.us/themes/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/1911623/66016573-97df9c00-e4ad-11e9-9095-225d5c9b46a8.png" alt="Code Surfer Themes"></a></p><p>在 <a href="https://github.com/pomber/code-surfer/blob/code-surfer-v2/packs/themes/src/index.ts" target="_blank" rel="noopener"><code>@code-surfer/themes</code></a> 包里面有许多Code Surfer主题。</p><p>你可以通过 theme 传递 prop <code>&lt;CodeSurfer theme={someTheme}&gt;</code>:</p><p>​````md<br>import { CodeSurfer } from “code-surfer”<br>import { nightOwl } from “@code-surfer/themes”</p><CodeSurfer theme={nightOwl}><p>​```js<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>&lt;/CodeSurfer&gt;</code></pre><p>或者像设置其他任何<a href="https://github.com/jxnblk/mdx-deck#theming" target="_blank" rel="noopener">MDX Deck 主题</a>一样设置整个项目的主题：</p><p>​````md<br>import { CodeSurfer } from “code-surfer”<br>import { nightOwl } from “@code-surfer/themes”</p><p>export const theme = nightOwl</p><CodeSurfer><p>​```js<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>&lt;/CodeSurfer&gt;</code></pre><blockquote><p>以这种方式导出主题还将更改未使用Code Surfer的幻灯片的文本和背景颜色。如果要保留其他mdx主题的颜色，可以将<a href="https://github.com/jxnblk/mdx-deck/blob/master/docs/theming.md#composing-themes" target="_blank" rel="noopener">两个主题组合在一起</a>：<code>export const themes = [codeSurferTheme, mdxDeckTheme]</code></p></blockquote><h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><p>你可以编写自己的Code Surfer主题，更改代码，标题和副标题的样式：</p><blockquote><p>在主题中使用 <a href="https://theme-ui.com/" target="_blank" rel="noopener">Theme UI</a></p></blockquote><p>​```js<br>// custom-theme.js<br>export default {<br>  colors: {<br>    background: “#222”,<br>    text: “#ddd”,<br>    primary: “#a66”<br>  },<br>  styles: {<br>    CodeSurfer: {<br>      pre: {<br>        color: “text”,<br>        backgroundColor: “background”<br>      },<br>      code: {<br>        color: “text”,<br>        backgroundColor: “background”<br>      },<br>      tokens: {<br>        “comment cdata doctype”: {<br>          fontStyle: “italic”<br>        },<br>        “builtin changed keyword punctuation operator tag deleted string attr-value char number inserted”: {<br>          color: “primary”<br>        },<br>        “line-number”: {<br>          opacity: 0.8<br>        }<br>      },<br>      title: {<br>        backgroundColor: “background”,<br>        color: “text”<br>      },<br>      subtitle: {<br>        color: “#d6deeb”,<br>        backgroundColor: “rgba(10,10,10,0.9)”<br>      },<br>      unfocused: {<br>        // only the opacity of unfocused code can be changed<br>        opacity: 0.1<br>      }<br>    }<br>  }<br>};</p><pre><code>像其他卡片主题一样使用它:````mdimport { CodeSurfer } from &quot;code-surfer&quot;import customTheme from &quot;./custom-theme&quot;&lt;CodeSurfer theme={customTheme}&gt;​```jsconsole.log(1);console.log(2);console.log(3);</code></pre></CodeSurfer>````<h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>Code Surfer 使用 <a href="https://prismjs.com/" target="_blank" rel="noopener">Prism</a> 解析不同的语言, 因此它支持 <a href="https://prismjs.com/#supported-languages" target="_blank" rel="noopener">Prism 支持的所有语言</a>.</p><p>开箱即用的支持大多数流行语言，其余的则需要导入它们:</p><p>​````md<br>import { CodeSurfer } from “code-surfer”<br>import “prismjs/components/prism-smalltalk”</p><CodeSurfer><p>​```smalltalk<br>result := a &gt; b<br>    ifTrue:[ ‘greater’ ]<br>    ifFalse:[ ‘less or equal’ ]</p><pre><code>&lt;/CodeSurfer&gt;</code></pre><h2 id="列"><a href="#列" class="headerlink" title="列"></a>列</h2><p>如果需要同时显示多个代码, 请使用 <code>&lt;CodeSurferColumns&gt;</code>:</p><p>​````md<br>import { CodeSurferColumns, Step } from “code-surfer”</p><CodeSurferColumns><Step subtitle="First Step"><p>​```js<br>console.log(1);<br>console.log(2);</p><pre><code>```jsconsole.log(&quot;a&quot;);console.log(&quot;b&quot;);</code></pre></Step><Step subtitle="Second Step"><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></Step></CodeSurferColumns>````<p>每个 <code>&lt;Step&gt;</code> 有自己的 <code>title</code> and <code>subtitle</code>.</p><p>你可以为各列使用不同的主题: <code>&lt;CodeSurferColumns themes={[nightOwl, ultramin]}&gt;</code>. 并更改列的相对大小 <code>&lt;CodeSurferColumns sizes={[1,3]}&gt;</code>.</p><p>列不仅用于代码，还可以将它们用于任何类型的内容：</p><p>​````md<br>import { CodeSurferColumns, Step } from “code-surfer”<br>import MyComponent from “./my-component.jsx”</p><CodeSurferColumns><Step><p>​```js<br>console.log(1);<br>console.log(2);</p><pre><code># Some Markdown&lt;/Step&gt;&lt;Step&gt;```js 2console.log(1);console.log(2);</code></pre><MyComponent/></Step></CodeSurferColumns>````<h2 id="导入代码文件"><a href="#导入代码文件" class="headerlink" title="导入代码文件"></a>导入代码文件</h2><p>你可以从文件中导入代码，而不必在代码块中编写代码：</p><p>​````md<br>import { CodeSurfer } from “code-surfer”</p><CodeSurfer><p>​```js 5:10 file=./my-code.js</p><pre><code>```js file=./my-other-code.js</code></pre></CodeSurfer>````<h2 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h2><p>要显示行号，将<code>showNumbers</code>添加到语言标识之后:</p><p>​````md<br>import { CodeSurfer } from “code-surfer”</p><CodeSurfer><p>​```js showNumbers<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>```jsconsole.log(1);console.log(2);console.log(4);</code></pre></CodeSurfer>````<h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><p>代码块也可以展示差异。 This is particularly useful when using empty diffs for code that doesn’t change:</p><p>代码块也可以展示差异。 当讲空的diffs用在不变的代码块时候，这特别有用：</p><p>​````md<br>import { CodeSurfer } from “code-surfer”</p><CodeSurfer><p>​```js<br>console.log(1);<br>console.log(2);<br>console.log(3);</p><pre><code>```diff 1 subtitle=&quot;log 1&quot;</code></pre><pre class=" language-diff"><code class="language-diff"></code></pre><pre class=" language-diff"><code class="language-diff"></code></pre></CodeSurfer>````<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ul><li><a href="https://github.com/jxnblk/mdx-deck" target="_blank" rel="noopener">MDX Deck</a></li><li><a href="https://github.com/jamiebuilds/spectacle-code-slide" target="_blank" rel="noopener">spectacle-code-slide</a></li><li><a href="https://github.com/PrismJS/prism" target="_blank" rel="noopener">Prism</a></li><li><a href="https://github.com/pomber/create-code-surfer-deck" target="_blank" rel="noopener">create-code-surfer-deck</a></li><li><a href="https://github.com/pomber/gatsby-waves" target="_blank" rel="noopener">Gatsby Waves</a></li></ul><h2 id="支持-Code-Surfer"><a href="#支持-Code-Surfer" class="headerlink" title="支持 Code Surfer"></a>支持 Code Surfer</h2><p>你可以帮助保持该项目的生命。</p><h3 id="赞助商"><a href="#赞助商" class="headerlink" title="赞助商"></a>赞助商</h3><p>通过成为赞助者来支持该项目。你的徽标将显示在此处，并带有指向你网站的链接。 [<a href="https://opencollective.com/code-surfer#sponsor" target="_blank" rel="noopener">成为赞助商</a>]</p><p><a href="https://opencollective.com/code-surfer/sponsor/0/website" target="_blank"><img src="https://opencollective.com/code-surfer/sponsor/0/avatar.svg"></a></p><h3 id="支持者"><a href="#支持者" class="headerlink" title="支持者"></a>支持者</h3><p>感谢所有的支持者! 🙏 [<a href="https://opencollective.com/code-surfer#backer" target="_blank" rel="noopener">成为支持者</a>]</p><p><a href="https://opencollective.com/code-surfer#backers" target="_blank"><img src="https://opencollective.com/code-surfer/backers.svg?width=890"></a></p><h3 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h3><p>这个项目的存在要感谢所有贡献者。<br><img src="https://opencollective.com/code-surfer/contributors.svg?width=890&button=false" /></p><p>````</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code-surfer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在nuxtjs中组织api调用</title>
      <link href="/2020/04/20/front-end/axios-in-nuxt/"/>
      <url>/2020/04/20/front-end/axios-in-nuxt/</url>
      
        <content type="html"><![CDATA[<p>对与api的组织调用，nuxtjs的官方文档都是<code>axios.get(&#39;https://jsonplaceholder.typicode.com/users&#39;)</code>这样的格式。简单的用一用，也问题不大，但是项目一大之后，对请求url的管理，前置，后置拦截器的处理，就比较麻烦了。</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器的设置相对简单，官方文档也有介绍。</p><p>这里传入的参数是<code>context</code>,<code>$axios, store</code>都是挂载在它上面的属性。</p><p>不要使用 <code>import axios from &#39;axios&#39;</code>的形式,在<code>nuxt</code>中，<code>axios</code>可以在服务端，和客户端两种环境执行，框架已经对这两种情况做了封装，直接在插件目录引用<code>axios</code>就可以</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// plugins/axios.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">{</span> $axios<span class="token punctuation">,</span> store <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  $axios<span class="token punctuation">.</span><span class="token function">onRequest</span><span class="token punctuation">(</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">)</span>    store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'showloading'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> config  <span class="token punctuation">}</span><span class="token punctuation">)</span>  $axios<span class="token punctuation">.</span><span class="token function">onResponse</span><span class="token punctuation">(</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'showloading'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> response    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  $axios<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'showloading'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="api-的组织和分离"><a href="#api-的组织和分离" class="headerlink" title="api 的组织和分离"></a>api 的组织和分离</h3><p>但是怎么样分离<code>api</code>?</p><h4 id="1-依赖注入的方式注入axios"><a href="#1-依赖注入的方式注入axios" class="headerlink" title="1. 依赖注入的方式注入axios"></a>1. 依赖注入的方式注入<code>axios</code></h4><p>通过函数参数的形式，把<code>axios</code>注入到上下文中，直接调用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// api/index.js</span><span class="token comment" spellcheck="true">// 高阶函数</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span>axios<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">index</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/word'</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="2-使用nuxtjs插件注入axios"><a href="#2-使用nuxtjs插件注入axios" class="headerlink" title="2.使用nuxtjs插件注入axios"></a>2.使用<code>nuxtjs</code>插件注入<code>axios</code></h4><ul><li>我们如何在整个Nuxt应用程序中<strong>访问</strong><code>api</code>？</li><li>我们如何从Nuxt模块正确<strong>传入</strong> axios实例？</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// plugins/axios-api-plugin.js</span><span class="token keyword">import</span> createApi <span class="token keyword">from</span> <span class="token string">'~/api/index'</span><span class="token comment" spellcheck="true">// 这里ctx也可以访问到store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> inject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 注入上下文</span>  <span class="token comment" spellcheck="true">// 挂载到vue实例上面 (组件中使用：this.$api)</span>  <span class="token keyword">const</span> apiAxios <span class="token operator">=</span> <span class="token function">createApi</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>$axios<span class="token punctuation">)</span>  <span class="token function">inject</span><span class="token punctuation">(</span><span class="token string">'api'</span><span class="token punctuation">,</span> <span class="token function">apiAxios</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>再把上面的代码作为插件配置到<code>plugins</code>中就可以像这样调用api：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 客户端 </span><span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$api<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 服务端 asyncData /fetch</span><span class="token keyword">await</span> ctx<span class="token punctuation">.</span>app<span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span></code></pre><p>这样封装之后，模块清晰，可维护性大大增加。</p><h3 id="可运行示例："><a href="#可运行示例：" class="headerlink" title="可运行示例："></a>可运行示例：</h3><p><a href="https://github.com/justOneWord/one_word_web" target="_blank" rel="noopener">https://github.com/justOneWord/one_word_web</a></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.lichter.io/posts/nuxt-api-call-organization-and-decoupling/" target="_blank" rel="noopener">https://blog.lichter.io/posts/nuxt-api-call-organization-and-decoupling/</a></p><p><a href="https://codesandbox.io/s/github/manniL/nuxt-decouple-and-organize-api-calls" target="_blank" rel="noopener">https://codesandbox.io/s/github/manniL/nuxt-decouple-and-organize-api-calls</a></p><p><a href="https://zh.nuxtjs.org/api/context" target="_blank" rel="noopener">https://zh.nuxtjs.org/api/context</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础Linux学习</title>
      <link href="/2020/03/29/ops/learnlinux/"/>
      <url>/2020/03/29/ops/learnlinux/</url>
      
        <content type="html"><![CDATA[<p>现在的服务都是部署在宝塔的基础上，基本是0技术要求，学习Linux，准备在下半年的服务换成原生的linux，不再依赖第三方控制面板。以下学习都是以<code>Centos 7</code>为基础。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p><code>init 0</code>: 关机</p></li><li><p><code>init 6</code>: 重启</p></li><li><p><code>ip addr</code>: 获取 ip 地址</p></li><li><p><code>pwd</code>: 显示当前路径</p></li><li><p><code>clear</code>或者<code>ctrl + l</code>:  清屏</p></li><li><p><code>history</code> ：查看历史命令</p></li><li><p><code>! + num</code>：使用历史命令</p></li></ol><h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><ol><li>添加用户：<code>useradd zhangsan</code></li><li>设置密码：<code>passwd zhangsan</code></li><li>删除用户：<code>userdel -rf zhangsan</code></li></ol><h3 id="Linux-常见目录结构"><a href="#Linux-常见目录结构" class="headerlink" title="Linux 常见目录结构"></a>Linux 常见目录结构</h3><p><strong>root 目录：</strong>linxu 超级权限root 的主目录。*</p><p><strong>home 目录：</strong>系统默认的用户主目录，如果添加用户是不指定用户的主目录，默认在/home<br>下创建与用户同名的文件夹。*</p><p><strong>bin 目录：</strong>存放系统所需要的重要命令，比如文件或目录操作的命令ls、cp、mkdir 等，另外<br>/usr/bin 也放了一些系统命令。这些命令对应着文件都是可以执行的。*</p><p><strong>sbin 目录：</strong>存放只有root 超级管理员才能执行的程序*</p><p><strong>boot 目录：</strong>存放着linux 启动时内核及引导系统程序所需要的核心文件，内核文件和grub<br>系统引导管理器都位于此目录。</p><p><strong>dev 目录：</strong>存放这linux 系统下的设备文件，如光驱等。</p><p><strong>etc 目录：</strong>存放系统的配置文件，作为一些软件启动时默认配置文件读取的目录，如/etc/fstal<br>存放系统分析信息。*</p><p><strong>mnt 目录：</strong> 临时文件挂载目录、也可以说是测试目录</p><p><strong>opt 目录：</strong> 第三方软件存放目录*</p><p><strong>media 目录：</strong>即插即用型设备挂载点，光盘默认挂载点，通常光盘挂载于/mnt/cdrom 下。</p><p><strong>tmp 目录：</strong>临时文件夹。*</p><p><strong>usr 目录：</strong>应用程序存放目录，安装linux 软件包是默认安装到/usr/local 目录下。*</p><p><strong>var 目录：</strong>目录经常变动，/var/log 存放系统日志，/var/log 存放系统库文件。*</p><h3 id="Linux-文件管理"><a href="#Linux-文件管理" class="headerlink" title="Linux 文件管理"></a>Linux 文件管理</h3><ol><li><p>创建文件： </p><p><code>touch file</code></p></li><li><p>删除文件：</p><p><code>rm -rf file</code></p><p><strong>-r:</strong> 递归的删除目录下面文件以及子目录下文</p><p><strong>-f:</strong> 强制删除，忽略不存在的文件，不给出提示</p></li><li><p>移动文件/修改文件名</p><p><code>mv file1 file2</code></p></li><li><p>查看文件内容</p><p><code>cat file</code></p></li><li><p>复制文件</p><p><code>cp file1 file2</code></p></li><li><p>批量创建文件</p><pre class=" language-shell"><code class="language-shell">touch file{1..10}touch -rd file{1..10}</code></pre></li><li><p>编辑文件</p><p><code>vi file</code></p></li><li><p>管道方式查看文件</p><pre class=" language-shell"><code class="language-shell">cat file | head -3 // 查看前3行cat file | tail -3 // 查看后3行</code></pre></li><li><p>文件查找</p><p>方法1：</p><p><code>find 目录 -name 文件名</code></p><p>方法2（更快）：</p><pre class=" language-bash"><code class="language-bash">// 建立数据库updatedb// 数据库中查找<span class="token function">locate</span> aa.txt </code></pre></li></ol><h3 id="Linux-目录管理"><a href="#Linux-目录管理" class="headerlink" title="Linux 目录管理"></a>Linux 目录管理</h3><ol><li><p>创建目录</p><p><code>mkdir dir1 dir2 dir3</code></p></li><li><p>重命名/移动目录</p><p><code>mv dir 1 dir2</code></p></li><li><p>删除目录</p><p><code>rm -rf dir1</code></p></li><li><p>复制目录</p><p><code>cp -rf dir1 dir2</code></p></li><li><p>显示目录结构</p><p><code>tree(需要安装)</code></p></li></ol><h3 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h3><ol><li><p>​    查看文件类型<code>ll</code></p></li><li><p>​    常见文件类型</p><pre class=" language-shell"><code class="language-shell">-rw-r—r— "-“开头的都是普通文件;drw-r—r— "d"开头的是目录文件;lrw-r—r— "l"开头的文件都是软链接文件;</code></pre></li></ol><h3 id="Linux-打包压缩"><a href="#Linux-打包压缩" class="headerlink" title="Linux 打包压缩"></a>Linux 打包压缩</h3><ol><li><p>Zip</p><p>压缩：</p><p><code>zip -r public.zip public</code></p><p>-r    表示将指定的目录下的所有子目录以及文件一起处理</p><p>解压：</p><p><code>unzip public.zip -d dir</code></p><p>查看压缩包内容</p><p><code>unzip -l public.zip</code></p></li><li><p>gz 压缩包</p><pre class=" language-shell"><code class="language-shell">tar czvf public.tar.gz public // 压缩tar xzvf public.atr.gz // 解压tar tf public.atr.gz // 查看tar cvf public.tar public // 仅打包，不压缩tar xvf public.tar // 解压无gz的包</code></pre></li></ol><h3 id="Linux-别名管理"><a href="#Linux-别名管理" class="headerlink" title="Linux 别名管理"></a>Linux 别名管理</h3><pre><code>// 添加别名alias aa=&#39;cat /etc/httpd/conf/httpd.conf&#39;// 删除别名unalias aa// 查看别名alias</code></pre><h3 id="内存、cup-管理"><a href="#内存、cup-管理" class="headerlink" title="内存、cup 管理"></a>内存、cup 管理</h3><p><code>top</code></p><ol><li><p>第一行</p><pre class=" language-shell"><code class="language-shell">top - 15:31:47 up 9:30, 3 users, load average: 0.00, 0.02, 0.05</code></pre><p>依次对应：系统当前时间 up 系统到目前为止i 运行的时间， 当前登陆系统的用户数量， load average 后<br>面的三个数字分别表示距离现在一分钟，五分钟，十五分钟的负载情况。</p></li></ol><ol start="2"><li><p>第二行</p><pre><code>Tasks: 133 total, 1 running, 132 sleeping, 0 stopped, 0 zombie</code></pre><p>依次对应：tasks 表示任务（进程），133 total 则表示现在有133 个进程，其中处于运行中<br>的有1 个，132 个在休眠（挂起），stopped 状态即停止的进程数为0，zombie 状态即僵尸<br>的进程数为0 个。</p></li><li><p>top 命令的第三行，cpu 状态：</p><pre class=" language-shell"><code class="language-shell">%Cpu(s): 0.2 us, 0.4 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.1 si, 0.0 st</code></pre><p><strong>只看空闲就可以了</strong>：cpu 空闲率为99.3%</p><p>依次对应：<br><strong>us</strong>:user 用户空间占用cpu 的百分比<br><strong>sy</strong>:system 内核空间占用cpu 的百分比<br><strong>ni</strong>:niced 改变过优先级的进程占用cpu 的百分比<br><strong>id</strong>:空闲cpu 百分比<br><strong>wa</strong>:IO wait IO 等待占用cpu 的百分比<br><strong>hi</strong>:Hardware IRQ 硬中断占用cpu 的百分比<br><strong>si</strong>:software 软中断占用cpu 的百分比<br><strong>st</strong>:被hypervisor 偷去的时间</p></li><li><p>top 命令的第四行，内存状态：</p><pre><code>KiB Mem : 2897496 total, 1995628 free, 191852 used, 710016 buff/cache</code></pre><p>总内存:2.76g 空闲：1995628/1024/1024=1.9g 已经使用0.18g 缓存区内存0.67g<br>缓冲区是从主内存中特地预留出的内存，用来存放特定的一些信息，例如从磁盘中取得的文件表，程序正<br>在读取的内容等等</p></li><li><p>top 命令第七行，各进程的监控：</p><pre><code>PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</code></pre><p>依次对应：<br><strong>PID</strong> — 进程id<br><strong>USER</strong> — 进程所有者<br><strong>PR</strong> — 进程优先级<br><strong>NI</strong> — nice 值。负值表示高优先级，正值表示低优先级<br><strong>VIRT</strong> — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p><p><strong>RES</strong> — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br><strong>SHR</strong> — 共享内存大小，单位kb<br><strong>S</strong> — 进程状态。D=不可中断的睡眠状态R=运行S=睡眠T=跟踪/停止Z=僵尸进程<br>**%CPU** — 上次更新到现在的CPU 时间占用百分比<br>**%MEM** — 进程使用的物理内存百分比<br><strong>TIME+</strong> — 进程使用的CPU 时间总计，单位1/100 秒<br><strong>COMMAND</strong> — 进程名称（命令名/命令行）</p></li></ol><p><code>uptime</code></p><ol><li><p>uptime</p><pre><code>top - 15:31:47 up 9:30, 3 users, load average: 0.00, 0.02, 0.05</code></pre><p>1.服务器工作时间<br>2.在线用户<br>3.平均负载一分钟，五分钟，十五分钟的负载情况</p></li></ol><h3 id="查看登录用户"><a href="#查看登录用户" class="headerlink" title="查看登录用户"></a>查看登录用户</h3><ol><li><p><code>who</code>:显示当前正在系统中的所有用户名字，使用终端设备号，注册时间</p></li><li><p><code>who am i</code>: 显示出当前终端上使用的用户</p></li><li><p><code>last</code>:显示近期用户或终端的登录情况</p></li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li><p>查看进程</p><pre class=" language-shell"><code class="language-shell">pstree # 查看进程树pstree -ap #显示所有详细(进程、子进程、进程号)pstree | grep httpdpstree -ap | grep httpd</code></pre></li><li><p>关闭进程</p><pre class=" language-shell"><code class="language-shell">pkill httpd # pkill 进程的名字kill 2245 # 进程号kill -9 2245   # 强制杀死进程</code></pre></li></ol><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><pre class=" language-shell"><code class="language-shell">netstat -tunpl |grep httpd </code></pre><p> -t 或–tcp 显示TCP 传输协议的连线状况。</p><p> -u 或–udp 显示UDP 传输协议的连线状况。</p><p> -n 或–numeric 直接使用IP 地址，而不通过域名服务器。</p><p> -p 或–programs 显示正在使用Socket 的程序识别码和程序名称。</p><p> -l 或–listening 显示监控中的服务器的Socket。</p><h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><pre><code>dfdf -h # 以人们易读的方式显示，总共多少g 用了多少gdf /home # 查看该文件夹所在磁盘的使用情况</code></pre><h3 id="使用-systemctl-管理服务"><a href="#使用-systemctl-管理服务" class="headerlink" title="使用 systemctl 管理服务"></a>使用 systemctl 管理服务</h3><p>systemctl 就是service 和chkconfig 这两个命令的整合，在CentOS 7 就开始被使用了,systemctl<br>是系统服务管理器命令，它实际上将service 和chkconfig 这两个命令组合到一起。</p><pre class=" language-shell"><code class="language-shell">systemctl start nginx # 启动服务systemctl stop nginx # 关闭服务systemctl restart ngonx # 重启服务systemctl enable httpd # 设置开机自启动systemctl disable nginx # 停止开机自启动systemctl list-unit-files|grep enabled # 列出所有自启动服务systemctl reload nginx # 重新加载配置</code></pre><h3 id="Firewakkd-防火墙设置"><a href="#Firewakkd-防火墙设置" class="headerlink" title="Firewakkd 防火墙设置"></a>Firewakkd 防火墙设置</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre class=" language-shell"><code class="language-shell">systemctl start firewalld # 启动systemctl stop firewalld # 关闭systemctl status firewalled # 查看状态systemctl disable firewalld # 开机禁用systemctl enable firewalld # 开机启用</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre class=" language-shell"><code class="language-shell">firewall-cmd --state # 显示状态firewall-cmd --zone=public --list-ports # 查看所有打开的端口firewall-cmd --reload # 更新规则firewall-cmd --zone=public --add-port=80/tcp --permanent  # 开启80端口，–permanent 永久生效，没有此参数重启后失效firewall-cmd --reload # 重新载入firewall-cmd --zone=public --query-port=80/tcp # 查看端口firewall-cmd --zone=public --remove-port=80/tcp --permanent # 删除</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端nuxt框架ssr初体验</title>
      <link href="/2020/03/08/front-end/qian-duan-nuxt-kuang-jia-ssr-chu-ti-yan/"/>
      <url>/2020/03/08/front-end/qian-duan-nuxt-kuang-jia-ssr-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>贵圈真乱..<code>nuxt、nest、next</code> ，已经快傻傻分不清楚了…</p><p>前端的车轮，碾压了青春，耗费了精力，疲于奔命，还是归本溯源，天知道…</p><h2 id="从前端的性能优化说起"><a href="#从前端的性能优化说起" class="headerlink" title="从前端的性能优化说起"></a>从前端的性能优化说起</h2><p>前端的性能优化，谷歌可以一大堆，他们说的当然都是非常有道理的。webpack打包优化，cdn，css权重，雪碧图？似乎都对。还记得一开始学前端时候，经常听到雅虎军规，曾经的优化圣经，现在还适用吗？</p><blockquote><p>雅虎军规：</p><ol><li>尽量减少HTTP请求数</li><li>使用内容发布网络</li><li>添加Expires头</li><li>压缩组件（使用gzip编码压缩http响应包）</li><li>将样式表放在顶部</li><li>将脚本放在底部</li><li>避免CSS表达式</li><li>使用外部的JavaScript和CSS</li><li>减少DNS查找</li><li>精简Javascript</li><li>避免重定向</li><li>移除重复脚本</li><li>配置ETag</li><li>使Ajax可缓存</li></ol></blockquote><p>我们现在基本上还是在遵守这些规则，只是有时候并不感知，打包工具帮我们做了大部分的事情。</p><p>前端性能优化，加快传输，加快渲染。现在的spa页面，不利于seo（虽然已经不重要了），无法避免加载白屏的问题。</p><p>历史，在召唤新的解决方案。</p><h3 id="高大上的ssr是什么"><a href="#高大上的ssr是什么" class="headerlink" title="高大上的ssr是什么"></a>高大上的ssr是什么</h3><p>服务端渲染，听起来就挺高大上的。然而，这并不是什么新技术。在很久很久以前<code>php</code>的<code>smarty</code>模板引擎，<code>java</code>的<code>jsp</code>，都可以称为服务端渲染。简单来说，服务端，给到客户端的是已经渲染好的html，浏览器可以立即解析，呈现页面。现在的主流框架都是空页面，然后加载js，通过js渲染出页面。</p><p>一般的spa页面，往往在渲染过程中，还会涉及<code>ajax</code>的请求发送，极端情况，可能一开始就有七八个请求，这种用户体验能好，才奇怪了。在这个过程中，页面基本上是不可用的，会出现loading状态，或者骨架屏状态。</p><p>能不能，复古一点，服务端直接渲染好页面，前端不发送初始化请求，前端拿到页面直接渲染，交互再通过ajax？</p><p><code>vue</code>也提供了ssr的渲染方案，社区中比较成熟的要数<code>nuxt</code>实现。</p><h3 id="nuxt-入门"><a href="#nuxt-入门" class="headerlink" title="nuxt 入门"></a>nuxt 入门</h3><p>nuxt 整体学习门槛不高，我整理下我学习遇到的集个问题，详细的还请查看文档。</p><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><pre class=" language-javascript"><code class="language-javascript">$ npx create<span class="token operator">-</span>nuxt<span class="token operator">-</span>app <span class="token operator">&lt;</span>项目名<span class="token operator">></span></code></pre><h4 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h4><p>在pages目录下的vue文件，会自动配置为路由，不需要手动配置。参数的获取遵循约定即可（详情，请查看文档）</p><h4 id="3-异步数据-asyncData"><a href="#3-异步数据-asyncData" class="headerlink" title="3. 异步数据(asyncData)"></a>3. 异步数据(<code>asyncData</code>)</h4><p>框架提供了<code>asyncData</code>获取异步数据，注意：<code>asyncData</code>方法会在组件（<strong>限于页面组件</strong>）每次加载之前被调用。它可以在服务端或路由更新之前被调用。</p><p><code>asyncData</code>执行的时候，页面还没有初始化，访问不到页面的方法，<code>asyncData</code>的返回结果，会被挂载到页面的data上面，渲染的时候，可以拿到数据，<code>server</code>端渲染为<code>html</code></p><h4 id="4-异步数据（fetch）"><a href="#4-异步数据（fetch）" class="headerlink" title="4.异步数据（fetch）"></a>4.异步数据（fetch）</h4><p><em>fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。</em></p><h4 id="5-vuex"><a href="#5-vuex" class="headerlink" title="5. vuex"></a>5. vuex</h4><p>按照示例直接声明即可，不需要进行实例化</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>  counter<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>  increment <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    state<span class="token punctuation">.</span>counter<span class="token operator">++</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">const</span> actions<span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端执行</span>  <span class="token keyword">async</span> <span class="token function">nuxtServerInit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>      data<span class="token punctuation">:</span> <span class="token punctuation">{</span> code<span class="token punctuation">,</span> data <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'https://loacalhost:3000'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">===</span> <span class="token string">'000'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'setConfig'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>Config<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果，我想，设置初始化数据，然后再执行页面的<code>asyncData</code>方法，直接使用是不行的。需要在状态树中指定 <code>nuxtServerInit</code>方法。</p><p>页面首先执行<code>nuxtServerInit</code>方法，结束后触发<code>asyncData</code>或者页面<code>fetch</code>方法</p><p><img src="/images/render.jpg"></p><h4 id="6-插件机制"><a href="#6-插件机制" class="headerlink" title="6.插件机制"></a>6.插件机制</h4><p>一般的vue项目我们都是在<code>main.js</code>中引入插件使用。</p><p>在<code>next</code>项目中，需要在<code>plugins</code>文件夹下声明，并在<code>nuxt.config.js</code>中配置插件</p><h4 id="7-注意第三方包的引入方式"><a href="#7-注意第三方包的引入方式" class="headerlink" title="7.注意第三方包的引入方式"></a>7.注意第三方包的引入方式</h4><p>服务端是没有<code>window、document</code>的，如果第三方包含有这些，那么就会报错，需要指定这些包为浏览器渲染类型。</p><pre><code>let toolif (process.client) {  tool = require(&#39;name&#39;)}</code></pre><p>通过<code>commonjs</code>的方式引入，不能通过es6的方式引入。</p><h3 id="同构项目"><a href="#同构项目" class="headerlink" title="同构项目"></a>同构项目</h3><p>周末把公司的一个h5项目进行了同构。之前是 6s 出界面，然后是ajax请求，到可用差不多要7~8s。同构之后，初始请求全部放到服务端进行，1s出界面，2s dom渲染结束，页面可用。可以说，提升还是非常大的。</p><h3 id="大前端"><a href="#大前端" class="headerlink" title="大前端"></a>大前端</h3><p>使用了nuxt之后，前端真的不只是前端了，完全可以站在更高的角度去看待问题，能做到事情也更多了。api缓存，组件缓存，页面缓存，即使已经比较满意了，依然有很多可以优化的点。</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>node 作为中间层，可以做很多事情，大大拓展了前端的职业可能性。只要你愿意，可做的又岂止是一个中间层，可以把后端的事情也完全做完。</p><p>日志，监控，安全，涉及到的东西会越来越多。</p><p>同构，对体验无疑是有巨大帮助的，但是多出来的这么多运维成本，也是项目需要考虑的。</p><p>周末的<code>nuxt</code>体验就到此呐~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nuxt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nest 初体验</title>
      <link href="/2020/02/23/back-endback-end-nest-chu-ti-yan/"/>
      <url>/2020/02/23/back-endback-end-nest-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<p>假期中，学习了<code>nest</code>这个node后端框架。感觉整体比较简约，学习相对来说，比较容易。本篇，写一下自己对这个框架的理解。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>类angular的代码组织形式:<code>imports、module、service</code></li><li>基于<code>typescript</code>，面向未来，特别是基于装饰器的模式，代码变得非常简洁</li><li>底层基于<code>express</code>,支持更换为<code>fastify</code>平台，坐拥丰富的<code>express</code>中间件</li><li>拒绝刀耕火种，一直没有太深入的学习<code>koa</code>的一个重要原因。koa框架太简单，基本什么都做不了，都需要引入中间件，封装代码。<code>nest</code>对常用操作，做了丰富的封装，简单易上手。</li><li><code>node</code> 中的<code>spring</code>，<code>typescript</code>+<code>ioc</code>,值得学习~</li></ol><h3 id="入门安装"><a href="#入门安装" class="headerlink" title="入门安装"></a>入门安装</h3><ol><li><code>npm i -g @nestjs/cli</code></li><li><code>nest new project-name</code></li></ol><h3 id="文档理解"><a href="#文档理解" class="headerlink" title="文档理解"></a>文档理解</h3><p><a href="https://docs.nestjs.cn/6/firststeps" target="_blank" rel="noopener">官方文档</a> 写的还不错，看一遍，基本也能理解。不准备重复官方文档，针对文档的各个模块写一点自己的理解。</p><h4 id="控制器（controller）"><a href="#控制器（controller）" class="headerlink" title="控制器（controller）"></a>控制器（controller）</h4><p>可以看成是路由控制器，负责传入的请求和客户端的返回响应。</p><p>如果返回对象或者数组格式，会被自动包装成<code>JSON</code>格式。</p><h4 id="提供者（Providers）"><a href="#提供者（Providers）" class="headerlink" title="提供者（Providers）"></a>提供者（Providers）</h4><p>Provider只是一个用 <code>@Injectable()</code> 装饰器注释的类。通过Controller 的 <code>constructor</code>注入，并实例化。不需要手动实例化，也就是java中常说的依赖注入。</p><p>一般用来处理业务逻辑，数据库交互。</p><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件是在路由处理程序 <strong>之前</strong> 调用的函数。本质上，就是路由之前的函数调用。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li><strong>转换</strong>：管道将输入数据转换为所需的数据输出</li><li><strong>验证</strong>：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常;</li></ul><p>感觉<code>ValidationPipe</code> 用的会多一点，既可以用来做验证，也可以做转换。</p><h4 id="守卫"><a href="#守卫" class="headerlink" title="守卫"></a>守卫</h4><p>守卫是一个使用 <code>@Injectable()</code> 装饰器的类。 守卫应该实现 <code>CanActivate</code> 接口。</p><p>一般用来做鉴权，通过守卫函数，返回<code>True</code>或者<code>False</code>,实现鉴权。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>nest</code>现在每周20k的下载量，是koa的一半，但是他是一个面向未来的框架。基于typescript和类spring的架构，值得我投入时间去学习琢磨。</p><p>学习<code>nest</code>还有一个原因,假期尝试看了<code>java</code>的<code>spring boot</code>,概念实在是太繁杂了=-=，奴家实在是不会啊~</p><p>好啦，今年的个人项目后台就暂定为<code>nest</code>呐~</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端怎么样处理emoji表情</title>
      <link href="/2020/01/18/front-end/qian-duan-zen-me-yang-chu-li-emoji-biao-qing/"/>
      <url>/2020/01/18/front-end/qian-duan-zen-me-yang-chu-li-emoji-biao-qing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个 bug 的心路历程…</p><p>😀：新项目耶 ✌</p><p>🤔：怎么做是最佳实践呢</p><p>😁：终于好了</p><p>😎：测试通过，顺利上线</p><p>😱🥵😡：什么，线上 bug！</p></blockquote><p>一般而言，不推荐前端处理 emoji，最好的方式还是把数据库修改成 <code>utf8mb4</code>格式，但是，如果数据库不在你这里呢？如果是一个延续性项目呢…那前端可能没办法,就要自己去处理 emoji 了。</p><h3 id="emoji-是什么"><a href="#emoji-是什么" class="headerlink" title="emoji 是什么"></a>emoji 是什么</h3><p>emoji 是字符，不是图片。emoji 使用 Unicode 编码方式，可以方便的转换成其他格式。</p><p><a href="https://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97" target="_blank" rel="noopener">维基百科关于 emoji 的介绍</a></p><p><a href="https://charbase.com/1f602-unicode-face-with-tears-of-joy" target="_blank" rel="noopener">charbase.com</a> ，网站提供了，各种格式 emoji 编码的查看方式：</p><p><img src="/images/image-20200118191909665.png" alt="笑哭"></p><p>上图可以方便的查看笑哭的 Unicode 编码：U+1F602，Javascript Escape：”\ud83d\ude02”等。</p><h3 id="常见-emoji-处理方式"><a href="#常见-emoji-处理方式" class="headerlink" title="常见 emoji 处理方式"></a>常见 emoji 处理方式</h3><ol><li>后台更改数据库格式为<code>utf8mb4</code>格式</li><li>使用文字替换，比如微信，QQ 等是使用<code>[笑哭]</code>格式表示 😂，</li><li>文字替换，但是不使用系统的 emoji，而是根据文字显示图片，实现多端显示统一</li><li>使用系统自带的 emoji 表情</li></ol><h3 id="emoji-常用转换函数"><a href="#emoji-常用转换函数" class="headerlink" title="emoji 常用转换函数"></a>emoji 常用转换函数</h3><p>转换函数，涉及到 unicode 的编码算法，属于专有领域知识，比较复杂，需要的时候复制就行了…不必深究。</p><p>方法一：转成Unicode</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// https://github.com/channg/umoji/blob/master/src/emojiToUnicode.js</span><span class="token comment" spellcheck="true">// 转换为js编码方式  😀=>"\ud83d\ude00"</span><span class="token keyword">function</span> <span class="token function">emojiToUnicode</span><span class="token punctuation">(</span>emoji<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> backStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>emoji <span class="token operator">&amp;&amp;</span> emoji<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> char <span class="token keyword">of</span> emoji<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> index <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token number">65535</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> h <span class="token operator">=</span>          <span class="token string">"\\u"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">0x10000</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0x400</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xd800</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token string">"\\u"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">0x10000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x400</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xdc00</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        backStr <span class="token operator">=</span> backStr <span class="token operator">+</span> h <span class="token operator">+</span> c<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        backStr <span class="token operator">=</span> backStr <span class="token operator">+</span> char<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>backStr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> backStr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>方法二：转成HTML实体编码</p><p><strong>不推荐！！！</strong></p><p>如果显示HTML编码，那么在<code>vue</code>框架中必须使用<code>v-html</code>,这是非常危险的，很容易导致<code>xss</code>攻击！</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// https://jordonwang.github.io/2018/06/06/emoji-string/</span><span class="token comment" spellcheck="true">// 转换为HTML实体字符</span><span class="token keyword">function</span> <span class="token function">emojiToHTMLEscape</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> patt <span class="token operator">=</span> <span class="token regex">/[\ud800-\udbff][\udc00-\udfff]/g</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 检测utf16字符正则</span>  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>patt<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> H<span class="token punctuation">,</span> L<span class="token punctuation">,</span> code<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>char<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      H <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出高位</span>      L <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出低位</span>      code <span class="token operator">=</span> <span class="token punctuation">(</span>H <span class="token operator">-</span> <span class="token number">0xd800</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0x400</span> <span class="token operator">+</span> <span class="token number">0x10000</span> <span class="token operator">+</span> L <span class="token operator">-</span> <span class="token number">0xdc00</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转换算法</span>      <span class="token keyword">return</span> <span class="token string">"&amp;#"</span> <span class="token operator">+</span> code <span class="token operator">+</span> <span class="token string">";"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> char<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果想深入研究，可以参考：</p><p><a href="https://blog.csdn.net/binjly/article/details/47321043" target="_blank" rel="noopener">移动前端手机输入法自带 emoji 表情字符处理</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener">Unicode 与 JavaScript 详解</a></p><h3 id="bug-场景及解决办法"><a href="#bug-场景及解决办法" class="headerlink" title="bug 场景及解决办法"></a>bug 场景及解决办法</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 数据来自服务端,我传递时候做JSON编码，\被转义为\\</span><span class="token keyword">let</span> serverValue <span class="token operator">=</span> <span class="token string">"\\ud83d\\ude00\\ud83d\\ude00"</span><span class="token punctuation">;</span><span class="token keyword">let</span> value <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>serverValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>看起来是一切正常，没有问题。我传递给后端的数据，做<code>JSON.Stringfy(value)</code>编码，拿到时候，再对字符串做 <code>JSON.parse(value)</code>解码。</p><p>但是，线上报错。仔细研究发现，有些数据，并不是我传递给后端的，而这些数据里面含有 JSON 的非法字符，导致 JSON 报错。</p><p>解决方式也简单：</p><ol><li>不使用 JSON.parse 解码，直接替换\\为\,就可以直接显示在页面上</li><li>如果使用 JSON.parse 解码，加个 try catch</li></ol><p>似乎问题解决了，但是JS似乎并不能很好的处理\\为\，<a href="https://stackoverflow.com/questions/33685680/emoji-surrogate-string-with-javascript-how-to-parse" target="_blank" rel="noopener">stackoverflow</a>这个方法正则方法可以：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">parseUnicode</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex">/\\u([\d\w]{4})/gi</span><span class="token punctuation">;</span>    str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>match<span class="token punctuation">,</span> grp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>grp<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在线测试：</p><iframe scrolling="no" width="100%" height="500" src="https://jsfiddle.net/wukong/6e1fjz4w/23/embedded/js,html,result/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h3 id="JSON-对字符串的处理"><a href="#JSON-对字符串的处理" class="headerlink" title="JSON 对字符串的处理"></a>JSON 对字符串的处理</h3><p>前端使用 json，基本都是对 object 进行编码，解码，很少对字符串进行编码解码。如果 JSON.parse()遇到’&#39;，往往会报错，基本上都需要转义为‘’\\‘</p><p>自己对<code>JSON</code>规范并不熟悉，关于<code>JSON</code>以后单独再写一篇。</p><p><img src="/images/image-20200118203439540.png" alt="JSON 转义测试"></p><img src="/images/json.png" alt="轨道图" style="zoom: 33%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>问题最终定位在 JSON 的转义上面，虽然天天在用 JSON，但是并不理解，查了很多资料，还是一星半解，这篇博客是很难写好了…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> emoji </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Axios源码学习Promise的妙用</title>
      <link href="/2020/01/05/front-end/cong-axios-yuan-ma-xue-xi-promise-de-miao-yong/"/>
      <url>/2020/01/05/front-end/cong-axios-yuan-ma-xue-xi-promise-de-miao-yong/</url>
      
        <content type="html"><![CDATA[<p>惭愧，虽然一直在使用<code>Promise/async/await</code>，但是自己其实对<code>Promise</code>并不是特别理解，导致这次遇到问题时候，一直不是特别明白。</p><hr><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><blockquote><p>需求：前端定时刷新 token 接口</p></blockquote><p>分析：看起来不复杂，但是如果考虑到 token 有时间限制，超时不可用，同时发起多个请求，怎么样在更新 token 的时候，延迟其他请求的发送，这就有点复杂了。</p><p>接口我是用 axios 去请求，这部分功能应该都会在拦截其中实现。我遇到的难点，也就是如何 hold 住请求，等待 token 刷新，释放请求。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">"axios"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从localStorage中获取token，token存的是object信息，有tokenExpireTime和token两个字段</span><span class="token keyword">function</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> tokenObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    tokenObj <span class="token operator">=</span> storage<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tokenObj <span class="token operator">=</span> tokenObj <span class="token operator">?</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>tokenObj<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"get token from localStorage error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> tokenObj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">refreshToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// instance是当前request.js中已创建的axios实例</span>  <span class="token keyword">return</span> instance<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/refreshtoken"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 给实例添加一个setToken方法，用于登录后方便将最新token动态添加到header，同时将token保存在localStorage中</span>instance<span class="token punctuation">.</span>setToken <span class="token operator">=</span> obj <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  instance<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">.</span>token<span class="token punctuation">;</span>  window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里需要变成字符串后才能放到localStorage中</span><span class="token punctuation">}</span><span class="token punctuation">;</span>instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>  config <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> tokenObj <span class="token operator">=</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加请求头</span>    config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> tokenObj<span class="token punctuation">.</span>token<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 登录接口和刷新token接口绕过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      config<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"/rereshToken"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">||</span>      config<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> config<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tokenObj<span class="token punctuation">.</span>token <span class="token operator">&amp;&amp;</span> tokenObj<span class="token punctuation">.</span>tokenExpireTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">>=</span> tokenObj<span class="token punctuation">.</span>tokenExpireTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 立即刷新token</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRefreshing<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"刷新token ing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          isRefreshing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token function">refreshToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token keyword">const</span> <span class="token punctuation">{</span> token<span class="token punctuation">,</span> tokenExprieIn <span class="token punctuation">}</span> <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">;</span>              <span class="token keyword">const</span> tokenExpireTime <span class="token operator">=</span> now <span class="token operator">+</span> tokenExprieIn <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>              instance<span class="token punctuation">.</span><span class="token function">setToken</span><span class="token punctuation">(</span><span class="token punctuation">{</span> token<span class="token punctuation">,</span> tokenExpireTime <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              isRefreshing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> token<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>token <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"刷新token成功，执行队列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              requests<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cb <span class="token operator">=</span><span class="token operator">></span> <span class="token function">cb</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 执行完成后，清空队列</span>              requests <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"refresh token error: "</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> retryOriginalRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          requests<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>token <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 因为config中的token是旧的，所以刷新token后要将新token传进来</span>            config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> token<span class="token punctuation">;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> retryOriginalRequest<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> config<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Do something with request error</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 请求返回后拦截</span>instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>  response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> code <span class="token punctuation">}</span> <span class="token operator">=</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">===</span> <span class="token number">1234</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// token过期了，直接跳转到登录页</span>      window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> response<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"catch"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> instance<span class="token punctuation">;</span></code></pre><p>核心代码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 1. 保存 pendding 状态的 Promise 到数组 requests 里面</span><span class="token keyword">const</span> retryOriginalRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  requests<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>token <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> token<span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. 执行 pendding 的promise ，状态转为 resolve</span>requests<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cb <span class="token operator">=</span><span class="token operator">></span> <span class="token function">cb</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>参考文章：<a href="https://juejin.im/post/5dcac7686fb9a04a9e37b595" target="_blank" rel="noopener">axios 如何利用 promise 无痛刷新 token（二）</a></p><p>我在如何保存<code>Promise</code>,后续如何释放<code>Promise</code> 这里卡住了，他的实现比较巧妙。</p><ol><li>保存请求的 config 的 Promise 到数组中</li><li>在刷新 token 之后，再执行修改 Promise 状态</li></ol><p>然鹅，你以为我懂了…其实我还是懵逼的…</p><p><img src="/images/1-1578487578225.png" alt="奴家不会啊"></p><h2 id="如何理解-Promise"><a href="#如何理解-Promise" class="headerlink" title="如何理解 Promise"></a>如何理解 Promise</h2><blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> retryOriginalRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  requests<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>token <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 因为config中的token是旧的，所以刷新token后要将新token传进来</span>    config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> token<span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> retryOriginalRequest<span class="token punctuation">;</span></code></pre><p>这里返回的是 promise？？？</p><p>一般我们不是返回的 config 吗？返回 Promise 作甚？？？</p></blockquote><p>在学习<code>axios</code>源码的过程中，找到了答案。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorManager</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> interceptors<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>Interceptor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">></span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用拦截器</span>  <span class="token function">use</span><span class="token punctuation">(</span>resolved<span class="token punctuation">:</span> ResolvedFn<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> rejected<span class="token operator">?</span><span class="token punctuation">:</span> RejectedFn<span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      resolved<span class="token punctuation">,</span>      rejected    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>  <span class="token punctuation">}</span>  <span class="token function">forEach</span><span class="token punctuation">(</span>fn<span class="token punctuation">:</span> <span class="token punctuation">(</span>interceptor<span class="token punctuation">:</span> Interceptor<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>interceptor <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>interceptor <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fn</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">eject</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行流程：</p><pre class=" language-js"><code class="language-js"> <span class="token comment" spellcheck="true">//  链式调用</span>    <span class="token keyword">const</span> chain<span class="token punctuation">:</span> PromiseChain<span class="token operator">&lt;</span>any<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        resolved<span class="token punctuation">:</span> dispatchRequest<span class="token punctuation">,</span>        rejected<span class="token punctuation">:</span> undefined      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>interceptor <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//  后添加先执行</span>      chain<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>interceptor <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//  先添加先执行</span>      chain<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>chain<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span> resolved<span class="token punctuation">,</span> rejected <span class="token punctuation">}</span> <span class="token operator">=</span> chain<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span>      promise <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolved<span class="token punctuation">,</span> rejected<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> promise</code></pre><p>基本流程：</p><ol><li>使用 use 方法，使用拦截器，拦截器被 push 到<code>interceptors</code>中进行管理</li><li>合并基本配置之后，设置调用链<code>chain</code>,请求拦截器，从后往前<code>unishift</code>到 chain 中，响应拦截器被<code>push</code>到<code>chain</code>中，中间则是，调用执行方法，也就是<code>dispatchRequest</code></li><li>这样就保证了调用顺序，请求拦截器 -&gt;执行调用方法 -&gt;响应拦截器</li><li>数据的流转，全部是通过<code>promise</code>传递，这里<code>while</code>方法，还是递归</li></ol><h2 id="理解-axios-中的-Promise"><a href="#理解-axios-中的-Promise" class="headerlink" title="理解 axios 中的 Promise"></a>理解 axios 中的 Promise</h2><p>再回头看官方的示例：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Add a request interceptor</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>  <span class="token keyword">function</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Do something before request is sent</span>    <span class="token keyword">return</span> config<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Do something with request error</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>error 时候，返回 reject，正常时候，只返回了 config。在下一步的执行中，实际变成了</p><pre class=" language-js"><code class="language-js">promise <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">resolve</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">,</span> rejected<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通过一个问题去阅读源码，再去理解基础知识。有的知识点是知道了，有的是会用了，然而，并没有真正的理解，想举一反三，难呐 😭</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码点滴:第一期</title>
      <link href="/2019/12/08/anything/bian-ma-dian-di-di-yi-qi/"/>
      <url>/2019/12/08/anything/bian-ma-dian-di-di-yi-qi/</url>
      
        <content type="html"><![CDATA[<p>本周遇到几个有意思的问题。下面一一记录。</p><ol><li><p>（css）使用flex布局，如何保证上下行之间间距，并且最后一行和容器空间为0</p><p>元素之间使用margin-bottom保持距离，最后一行元素的距离，使用外层的负margin抵消</p><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/pL28utya/embedded/html,css,result/dark" frameborder="0" loading="lazy" allowfullscreen></iframe></li></ol><ol start="2"><li><p>（react）如何理解组件里面的普通函数和箭头函数</p><p>参考：<a href="https://www.zhihu.com/question/59025982" target="_blank" rel="noopener">https://www.zhihu.com/question/59025982</a></p><p>简单来说：</p><p>普通函数 <code>Foo.prototype.a = function(){}</code></p><p>箭头函数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span> a<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>普通函数挂载在原型上面，箭头函数挂载在对象上面。使用箭头函数绑定不需要使用<code>bind</code>，比较方便。</p></li><li><p>react native <code>keybordWillShow</code> 安卓是监听不到的，<code>statusbar</code>中<code>barStyle</code>在安卓上面也可以用，需要安卓6.0+</p></li><li><p>react-navigation </p><p>页面销毁：</p><p>a-&gt;b ：不会执行页面销毁事件</p><p>b返回a：执行b页面销毁事件</p></li><li><p>前端处理emoji表情 😀</p><p>正常应该数据库保存emoji表情，数据库使用<code>utf8mp4</code>，最完美的解决方案。</p><p>但是有时候，数据库是以前的，不可能变更，这时候前端可以把emoji转成utf-16，然后传给后端。可以直接使用<a href="https://github.com/channg/umoji" target="_blank" rel="noopener">umoji</a>的<code>emojiToUnicode</code>方法。</p></li></ol><p>   验证utf-16是否正确：<a href="https://www.browserling.com/tools/utf16-decode" target="_blank" rel="noopener">https://www.browserling.com/tools/utf16-decode</a></p><p>   前端如何解析这个utf-16 呢？<a href="https://www.jianshu.com/p/432425a02b59" target="_blank" rel="noopener">https://www.jianshu.com/p/432425a02b59</a></p><p>   编码解码函数：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 编码</span><span class="token keyword">function</span> <span class="token function">utf16toEntities</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">var</span> patt<span class="token operator">=</span><span class="token regex">/[\ud800-\udbff][\udc00-\udfff]/g</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 检测utf16字符正则 </span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>patt<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">var</span> H<span class="token punctuation">,</span> L<span class="token punctuation">,</span> code<span class="token punctuation">;</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>char<span class="token punctuation">.</span>length<span class="token operator">===</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     H <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出高位 </span>                    L <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出低位 </span>                    code <span class="token operator">=</span> <span class="token punctuation">(</span>H <span class="token operator">-</span> <span class="token number">0xD800</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0x400</span> <span class="token operator">+</span> <span class="token number">0x10000</span> <span class="token operator">+</span> L <span class="token operator">-</span> <span class="token number">0xDC00</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转换算法 </span>                    <span class="token keyword">return</span> <span class="token string">"&amp;#"</span> <span class="token operator">+</span> code <span class="token operator">+</span> <span class="token string">";"</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                  <span class="token keyword">return</span> char<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> str<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 解码</span><span class="token keyword">function</span> <span class="token function">uncodeUtf16</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/\&amp;#.*?;/g</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> result <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> H<span class="token punctuation">,</span>L<span class="token punctuation">,</span>code<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>char<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">9</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                code <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>char<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/[0-9]+/g</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                H <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>code<span class="token number">-0x10000</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0x400</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0xD800</span><span class="token punctuation">;</span>                L <span class="token operator">=</span> <span class="token punctuation">(</span>code <span class="token operator">-</span> <span class="token number">0x10000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x400</span> <span class="token operator">+</span> <span class="token number">0xDC00</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token function">unescape</span><span class="token punctuation">(</span><span class="token string">"%u"</span><span class="token operator">+</span>H<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"%u"</span><span class="token operator">+</span>L<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> char<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>   但是但是，我解析的时候直接<code>JSON.parse(emoji)</code>也是可以的….试了偏僻的字符也可以，想搞明白为什么，没有找到文章=-=，不知道是埋了炸弹，还是狗屎运/(ㄒoㄒ)/~~</p>]]></content>
      
      
      <categories>
          
          <category> 编码点滴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 周记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 沉浸式状态栏和导航栏</title>
      <link href="/2019/11/24/front-end/reactnative-ding-bu-tu-pian-she-zhi/"/>
      <url>/2019/11/24/front-end/reactnative-ding-bu-tu-pian-she-zhi/</url>
      
        <content type="html"><![CDATA[<p>最近开始接触 React Native 的开发工作，对原生开发基本不了解，里面很多大大小小的坑。这次开发内容不是很复杂，数据交互不是非常多，主要是页面的布局。</p><h2 id="如何实现一个顶部隐藏状态栏并显示导航栏的页面？"><a href="#如何实现一个顶部隐藏状态栏并显示导航栏的页面？" class="headerlink" title="如何实现一个顶部隐藏状态栏并显示导航栏的页面？"></a>如何实现一个顶部隐藏状态栏并显示导航栏的页面？</h2><p><img src="/images/image-20191124220426772.png" alt="产品图片"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>使用<code>Image</code>实现图片的显示，这里的图片最好使用<code>ImageBackground</code>组件，区别是<code>ImageBackground</code>可以嵌套其他组件</p></li><li><p>导航栏，我一开始是使用绝对定位的方式进行模拟的，但是越想越不对，实现肯定是有问题的，果然在<code>navigationOptions</code>中找到了<code>headerTransparent</code>属性，使用它，导航栏就可以实现透明显示。</p></li><li><p>状态栏透明显示：</p><pre class=" language-javascript"><code class="language-javascript">StatusBar<span class="token punctuation">.</span><span class="token function">setBackgroundColor</span><span class="token punctuation">(</span><span class="token string">"transparent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>StatusBar<span class="token punctuation">.</span><span class="token function">setTranslucent</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="可用参考示例"><a href="#可用参考示例" class="headerlink" title="可用参考示例"></a>可用参考示例</h2><p><a href="https://github.com/Yaob1990/ReactNativePlayGround/blob/master/src/pages/Bar.js" target="_blank" rel="noopener">沉浸式状态栏</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://www.jianshu.com/p/8075ccc84d07" target="_blank" rel="noopener">React Native 中的状态栏</a></li><li><a href="http://www.jeepxie.net/article/558579.html" target="_blank" rel="noopener">react native 沉浸式(透明)状态栏与标题导航栏</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混合开发 </tag>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weex兼容本地图片</title>
      <link href="/2019/07/05/front-end/weex-jian-rong-ben-di-tu-pian/"/>
      <url>/2019/07/05/front-end/weex-jian-rong-ben-di-tu-pian/</url>
      
        <content type="html"><![CDATA[<p>做 weex 开发时候，不能使用本地图片，比较难受，必须使用网络图片。<br>那么能不能本地开发的图片自动转成网络图片？</p><h3 id="兼容本地图片实现"><a href="#兼容本地图片实现" class="headerlink" title="兼容本地图片实现"></a>兼容本地图片实现</h3><p>本地图片都存放在/src/image 文件夹，通过 tool.getImage(“logo.png”) 访问图片。在运行和部署时候，图片地址转成网络地址。<br>适合 web，不适合 app 场景。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a href="https://github.com/aocoding/weex-local-image" target="_blank" rel="noopener">weex-local-image</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weex </tag>
            
            <tag> 混合开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vagrant 学习记录</title>
      <link href="/2019/01/06/tool/vagrant-xue-xi-ji-lu/"/>
      <url>/2019/01/06/tool/vagrant-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>Vagrant 是virtualBox的命令行管理工具。<br>以前在mac平台我会用mamp pro 作为php的开发环境，但是非正版毕竟不太好，而且开发环境不贴近实际线上，折腾了一下，使用 vagrant 成功代替mamp pro。</p><h3 id="1-安装vagrant"><a href="#1-安装vagrant" class="headerlink" title="1. 安装vagrant"></a>1. 安装vagrant</h3><pre><code>`brew cask install virtualbox` 安装 virtualbox`brew cask install vagrant` 安装 vagrant</code></pre><h3 id="2-使用镜像初始化虚拟机"><a href="#2-使用镜像初始化虚拟机" class="headerlink" title="2. 使用镜像初始化虚拟机"></a>2. 使用镜像初始化虚拟机</h3><pre><code>下载地址找个百度盘吧，官方的我实在是没有拖动。。。一点都没动。。。`vagrant init precise64` 其中 `precise64` 表示你的镜像文件</code></pre><h3 id="3-常用设置"><a href="#3-常用设置" class="headerlink" title="3. 常用设置"></a>3. 常用设置</h3><pre><code>vagrant up  启动虚拟机vagrant ssh ssh进入虚拟机</code></pre><p>配置文件：<br>需要设置的地方其实很少，也就是网络端口转发和本地其他机器访问的公共ip<br><code>config.vm.synced_folder</code>表示本地和虚拟机同步的文件夹。</p><pre><code>  config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 80  config.vm.network &quot;forwarded_port&quot;, guest: 8888, host: 8888  config.vm.network &quot;forwarded_port&quot;, guest: 888, host: 888  config.vm.network &quot;public_network&quot;, ip: &quot;192.168.1.120&quot;  config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;</code></pre><p>在开发中，发现php不能自动生成tpl模板文件，需要设置同步文件夹的权限</p><pre><code>config.vm.synced_folder      &quot;your_folder&quot;(必须)   //物理机目录，可以是绝对地址或相对地址，相对地址是指相对与vagrant配置文件所在目录  ,&quot;vm_folder(必须)&quot;    // 挂载到虚拟机上的目录地址  ,create(boolean)--可选     //默认为false，若配置为true，挂载到虚拟机上的目录若不存在则自动创建  ,disabled(boolean):--可选   //默认为false，若为true,则禁用该项挂载  ,owner(string):&#39;www&#39;--可选   //虚拟机系统下文件所有者(确保系统下有该用户，否则会报错)，默认为vagrant  ,group(string):&#39;www&#39;--可选   //虚拟机系统下文件所有组( (确保系统下有该用户组，否则会报错)，默认为vagrant  ,mount_options(array):[&quot;dmode=775&quot;,&quot;fmode=664&quot;]--可选  dmode配置目录权限，fmode配置文件权限  //默认权限777  ,type(string):--可选     //指定文件共享方式，例如：&#39;nfs&#39;，vagrant默认根据系统环境选择最佳的文件共享方式</code></pre><p>我的配置：<br><code>config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;,create: true, owner:&quot;www&quot;, group: &quot;www&quot;</code></p><h3 id="4-安装宝塔面板"><a href="#4-安装宝塔面板" class="headerlink" title="4. 安装宝塔面板"></a>4. 安装宝塔面板</h3><p>对我我等弱鸡鸡，宝塔面板还是很方便的。直接安装官方说明安装即可。注意，最后安装成功的ip是外网的ip，我们需要本地地址去访问。</p><h3 id="5-配置网站"><a href="#5-配置网站" class="headerlink" title="5. 配置网站"></a>5. 配置网站</h3><p>宝塔已经可以配置网站了。但是设置了之后，并不能访问。<br>需要去hosts 里面配置下网络地址，推荐使用<a href="https://oldj.github.io/SwitchHosts/" target="_blank" rel="noopener">SwitchHosts</a>去管理hosts。<br>eg：</p><pre><code># SwitchHosts!# vagrant127.0.0.1 www.test.com127.0.0.1 www.btadmin.com</code></pre><p>这时候就可以用<code>www.test.com</code>访问测试网站，用<code>www.btadmin.com</code>访问宝塔管理页面（需要在宝塔中配置）。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vagrant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/12/hello-world/"/>
      <url>/2018/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
